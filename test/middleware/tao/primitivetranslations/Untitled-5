
TEST(Re2Corba, INTEGER2SHORT){
    typedef double CORBA_TYPE;
    typedef RE_DOUBLE RE_TYPE;
    
    {
        RE_TYPE small = 16;

        auto small_test = IsValidConversion<RE_TYPE, short>(small);
        auto small_int2ushort = IsValidConversion<RE_TYPE, unsigned short>(small);
        auto small_int2uint = IsValidConversion<RE_TYPE, unsigned int>(small);
        auto small_int2int = IsValidConversion<RE_TYPE, int>(small);
        auto small_int2long = IsValidConversion<RE_TYPE, long>(small);
        auto small_int2longlong = IsValidConversion<RE_TYPE, long long>(small);

        EXPECT_TRUE(small_int2short);
        EXPECT_TRUE(small_int2ushort);
        EXPECT_TRUE(small_int2uint);
        EXPECT_TRUE(small_int2int);
        EXPECT_TRUE(small_int2long);
        EXPECT_TRUE(small_int2longlong);
    }

    {
        RE_TYPE max = std::numeric_limits<RE_TYPE>::max();

        auto max_int2short = IsValidConversion<RE_TYPE, short>(max);
        auto max_int2ushort = IsValidConversion<RE_TYPE, unsigned short>(max);
        auto max_int2uint = IsValidConversion<RE_TYPE, unsigned int>(max);
        auto max_int2int = IsValidConversion<RE_TYPE, int>(max);
        auto max_int2long = IsValidConversion<RE_TYPE, long>(max);
        auto max_int2longlong = IsValidConversion<RE_TYPE, long long>(max);

        EXPECT_FALSE(max_int2short);
        EXPECT_FALSE(max_int2ushort);
        EXPECT_TRUE(max_int2uint);
        EXPECT_TRUE(max_int2int);
        EXPECT_TRUE(max_int2long);
        EXPECT_TRUE(max_int2longlong);
    }

    {
        RE_TYPE neg_small = -16;

        auto neg_small_int2short = IsValidConversion<RE_TYPE, short>(neg_small);
        auto neg_small_int2ushort = IsValidConversion<RE_TYPE, unsigned short>(neg_small);
        auto neg_small_int2uint = IsValidConversion<RE_TYPE, unsigned int>(neg_small);
        auto neg_small_int2int = IsValidConversion<RE_TYPE, int>(neg_small);
        auto neg_small_int2long = IsValidConversion<RE_TYPE, long>(neg_small);
        auto neg_small_int2longlong = IsValidConversion<RE_TYPE, long long>(neg_small);
        
        EXPECT_TRUE(neg_small_int2short);
        EXPECT_FALSE(neg_small_int2ushort);
        EXPECT_FALSE(neg_small_int2uint);
        EXPECT_TRUE(neg_small_int2int);
        EXPECT_TRUE(neg_small_int2long);
        EXPECT_TRUE(neg_small_int2longlong);
    }

    {
        RE_TYPE min = std::numeric_limits<RE_TYPE>::min();

        auto min_int2short = IsValidConversion<RE_TYPE, short>(min);
        auto min_int2ushort = IsValidConversion<RE_TYPE, unsigned short>(min);
        auto min_int2uint = IsValidConversion<RE_TYPE, unsigned int>(min);
        auto min_int2int = IsValidConversion<RE_TYPE, int>(min);
        auto min_int2long = IsValidConversion<RE_TYPE, long>(min);
        auto min_int2longlong = IsValidConversion<RE_TYPE, long long>(min);

        EXPECT_FALSE(min_int2short);
        EXPECT_FALSE(min_int2ushort);
        EXPECT_FALSE(min_int2uint);
        EXPECT_TRUE(min_int2int);
        EXPECT_TRUE(min_int2long);
        EXPECT_TRUE(min_int2longlong);
    }


}