

// This method collects a list of Node names from the current Jenkins instance
@NonCPS
def nodeNames() {
  return jenkins.model.Jenkins.instance.nodes.collect { node -> node.name }
}

def getLabels(String name){
    def computer = Jenkins.getInstance().getComputer(name)
    def node = computer.getNode()
    if(computer.isOnline()){
        return node.getLabelString()
    }
    return ""
}

def runScript(String script){
    if(isUnix()){
        sh script
    }
    else{
        //TODO: do windows things here
    }
}

def masterNode = "${MASTER_NODE}"
def buildDir = "gen"
def buildArchiveDir = "build" + env.BUILD_ID

node(masterNode){
    def file = "${model_graphml}"
    def workspacePath = pwd()
    def reGenPath = "${RE_GEN_PATH}"
    def saxonPath = reGenPath

    def middlewareString = ' middlewares=zmq,proto,qpid,ospl,rti'
    def fileString = ' -s:' + reGenPath + '/' + file
    def jarString = 'java -jar '  + saxonPath + '/saxon.jar -xsl:' + reGenPath
    
    dir(reGenPath){
        if("${checkout}" == 'true'){
            stage('Checkout Transforms'){
                checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'SubmoduleOption', disableSubmodules: false, parentCredentials: true, recursiveSubmodules: false, reference: '', trackingSubmodules: false]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'f61aee32-b55a-4a7a-bef4-6372ed9fc94f', url: 'https://github.com/cdit-ma/re_gen.git']]])
            }
        }
    }

    def buildPath = workspacePath + "/" + buildDir
    
    dir(buildPath){
        stage('C++ Generation'){
            def typeGenCommand = jarString + '/g2datatypes.xsl' + fileString + middlewareString
            runScript(typeGenCommand)
            def componentGenCommand = jarString + '/g2components.xsl' + fileString + middlewareString
            runScript(componentGenCommand)
        }
    }

    stage('Archive'){
        dir(workspacePath){
            // Stash generated cpp files.
            stash includes: buildDir + '/**', name: 'codeGen'
        }
        dir(workspacePath + "/" + buildArchiveDir){
            unstash 'codeGen'
        }
    }
}

def names = nodeNames()
//filter nodes
def filtered_names = []
for(n in names){
    if(getLabels(n).contains("GEN")){
        filtered_names << n
        print("Got Node: " + n)
    }
}

//go to all nodes and build generated code in parallel
stage('Compile C++ Code'){
    def builders = [:]
    for(n in filtered_names){
        def node_name = n
        builders[node_name] = {
            node(node_name){
                dir(buildArchiveDir){
                    unstash 'codeGen'
                }
                unstash 'codeGen'
                dir(buildDir + "/build"){
                    sh 'cmake ..'
                    sh 'make'
                }
            }
        }
    }
    parallel builders
}


//TODO: filter based on deployment
def deployed_nodes = filtered_names

def masterPort = '7000'
def slavePort = '7001'

def libString = '-l .'
def modelString = '-d ${model_graphml}'
def slaveMode = "-s"
def masterMode = "-m"

stage('Execute Model'){
    def builders = [:]
    for(n in deployed_nodes){
        def node_name = n
        builders[node_name] = {
            node(node_name){
                //TODO: Extract deployment information here
                def ip = '192.168.111.161'
                def masterIP = 'tcp://' + ip + ':' + masterPort
                def slaveIP = 'tcp://' + ip + ':' + slavePort
                def otherArgs = '-t 60'
                def reNodeManager = "${RE_PATH}" + '/bin/re_node_manager'

                def reMaster = false;
                def reSlave = true;

                def json =  readJSON file: 'test.json'

                print(n)
                def slaveJson = json[n].re_node_manager.slave

                print(slaveJson)

                print(json['swiss11'].re_node_manager.slave)

                dir(buildDir + "/lib"){
                    def executionCommand = reNodeManager
                    if(reMaster){
                        executionCommand += " " + masterMode + " " + masterIP + " " + modelString
                    }
                    if(reSlave){
                        executionCommand += " " + slaveMode + " " + slaveIP + " " + libString
                    }
                    executionCommand +=  " " + otherArgs

                    //TODO:Change this to actually run el commando
                    print(executionCommand)
                    //runScript(executionCommand)
                }
            }
        }
    }
    parallel builders
}
