/*
def branches = [:]
def names = nodeNames()
for (int i=0; i<names.size(); ++i) {
  def nodeName = names[i];
  // Into each branch we put the pipeline code we want to execute
  branches["node_" + nodeName] = {
    node(nodeName) {
      echo "Triggering on " + nodeName
    }
  }
}
// Now we trigger all branches
parallel branches
// This method collects a list of Node names from the current Jenkins instance
@NonCPS
def nodeNames() {
  return jenkins.model.Jenkins.instance.nodes.collect { node -> node.name }
}
*/

node('swiss11'){
    print "GIT_CREDENTIAL_ID = ${GIT_CREDENTIAL_ID}"
    dir("${LOGAN_PATH}") {
        stage('Checkout'){
            checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'SubmoduleOption', disableSubmodules: false, parentCredentials: true, recursiveSubmodules: false, reference: '', trackingSubmodules: false]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: "${GIT_CREDENTIAL_ID}", url: 'https://github.com/cdit-ma/logan.git']]])
        }
        dir('build'){
            stage('CMake'){
                sh 'cmake ..'
            }
            stage('Make'){
                sh 'make -j6'
            }
        }
    }
}