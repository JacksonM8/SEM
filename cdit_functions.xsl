<!-- Functions for cpp syntax output -->
<xsl:stylesheet version="2.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:o="http://github.com/cdit-ma/re_gen/o"
    xmlns:graphml="http://github.com/cdit-ma/re_gen/graphml"
    xmlns:cdit="http://github.com/cdit-ma/re_gen/cdit"
    xmlns:cpp="http://github.com/cdit-ma/re_gen/cpp"
    xmlns:proto="http://github.com/cdit-ma/re_gen/proto"
    xmlns:idl="http://github.com/cdit-ma/re_gen/idl"
    xmlns:cmake="http://github.com/cdit-ma/re_gen/cmake"
    xmlns:gml="http://graphml.graphdrawing.org/xmlns"
    >

    <!--
        Get the version number
    -->
    <xsl:function name="cdit:get_re_gen_version" as="xs:string">
        <xsl:value-of select="'re_gen-v3.0.2'" />
    </xsl:function>

    <!--
        Print re-gen info
    -->
    <xsl:function name="cpp:print_regen_version">
        <xsl:param name="transform" as="xs:string" />
        <xsl:param name="function_name" as="xs:string" />
        <xsl:param name="tab" as="xs:integer" />
        
        <xsl:value-of select="cpp:comment(('Generated by:', $transform, o:wrap_bracket(cdit:get_re_gen_version()), o:nl(1), 'Function:', concat($function_name, o:wrap_bracket(''))), $tab)" />
        <xsl:value-of select="o:nl(1)" />
    </xsl:function>

    <!--
        Print re-gen info
    -->
    <xsl:function name="cmake:print_regen_version">
        <xsl:param name="transform" as="xs:string" />
        <xsl:param name="function_name" as="xs:string" />
        <xsl:param name="tab" as="xs:integer" />
        
        <xsl:value-of select="cmake:comment(('Generated by:', $transform, o:wrap_bracket(cdit:get_re_gen_version()), o:nl(1), 'Function:', concat($function_name, o:wrap_bracket(''))), $tab)" />
        <xsl:value-of select="o:nl(1)" />
    </xsl:function>


    <!--
        Gets the path to the aggregate folder
    -->
    <xsl:function name="cdit:get_datatype_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="file" as="xs:string" />

        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        <xsl:variable name="aggregate_label" select="graphml:get_label($aggregate)" />

         <xsl:value-of select="lower-case(o:join_paths(($middleware, $aggregate_namespace, $aggregate_label, $file)))" />
    </xsl:function>
    
    <!--
        Gets the name of the middleware_generated_header_name
    -->
    <xsl:function name="cdit:get_middleware_generated_header_name" as="xs:string">
        <xsl:param name="aggregate" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="middleware_extension">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti'">
                    <xsl:value-of select="'.hpp'" />
                </xsl:when>
                <xsl:when test="$middleware = 'ospl'">
                    <xsl:value-of select="'_DCPS.hpp'" />
                </xsl:when>
                <xsl:when test="$middleware = 'proto'">
                    <xsl:value-of select="'.pb.h'" />
                </xsl:when>
                <xsl:when test="$middleware = 'tao'">
                    <xsl:value-of select="'S.h'" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="o:warning(concat('Middleware ', $middleware, ' not implemented'))" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="file_name" select="cdit:get_aggregate_file_prefix($aggregate, $middleware)" />

        <xsl:value-of select="concat($file_name, $middleware_extension)" />
    </xsl:function>

    <xsl:function name="cdit:middleware_requires_idl_file" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:variable name="middleware_lc" select="lower-case($middleware)" />
        <xsl:value-of select="$middleware_lc = 'rti' or $middleware_lc = 'ospl' or $middleware_lc = 'tao'" />
    </xsl:function>

    <xsl:function name="cdit:middleware_requires_proto_file" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:variable name="middleware_lc" select="lower-case($middleware)" />
        <xsl:value-of select="$middleware_lc = 'proto'" />
    </xsl:function>



    <!--
        Gets the name of the middleware_generated_header_name
    -->
    <xsl:function name="cdit:middleware_uses_ref_setter" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string" />
        
        <xsl:value-of select="$middleware = 'rti' or $middleware = 'ospl' or cdit:middleware_uses_protobuf($middleware)" />
    </xsl:function>

    <xsl:function name="cdit:get_middleware_variable_syntax" as="xs:string">
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="label" select="graphml:get_label($node)" />

        <xsl:choose>
    
            <xsl:when test="$middleware = 'ospl' or $middleware = 'rti'">
                <!-- DDS uses exact case -->
                <xsl:value-of select="lower-case($label)" />
            </xsl:when>
            <xsl:when test="$middleware = 'tao'">
                <!-- DDS uses exact case -->
                <xsl:value-of select="lower-case($label)" />
            </xsl:when>
            <xsl:when test="$middleware = 'base'">
                <!-- Base uses exact case -->
                <xsl:value-of select="$label" />
            </xsl:when>
            <xsl:when test="cdit:middleware_uses_protobuf($middleware)">
                <!-- Protobuf uses lowercase -->
                <xsl:value-of select="lower-case($label)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:comment_inline(concat('Middleware ', $middleware, ' not implemented'))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:middleware_uses_protobuf" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:value-of select="$middleware='qpid' or $middleware='zmq' or $middleware='proto'" />
    </xsl:function>

    <xsl:function name="cdit:middleware_uses_dds" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:value-of select="$middleware='rti' or $middleware='ospl'" />
    </xsl:function>

    <xsl:function name="cdit:get_middleware_namespace" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:value-of select="lower-case($middleware)" />
    </xsl:function>

    <xsl:function name="cdit:invoke_middleware_get_function" as="xs:string">
        <xsl:param name="obj" as="xs:string"/>
        <xsl:param name="operator" as="xs:string"/>
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="parent_node" select="graphml:get_parent_node($node)" />
        <xsl:variable name="kind" select="graphml:get_kind($node)" />
        <xsl:variable name="node_type" select="graphml:get_type($node)" />
        <xsl:variable name="is_union" select="graphml:evaluate_data_value_as_boolean($parent_node, 'is_union')" />

        <xsl:variable name="variable_syntax" select="cdit:get_middleware_variable_syntax($node, $middleware)" />
        <xsl:variable name="function_name">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti'">
                    <xsl:choose>
                        <xsl:when test="$kind = 'EnumInstance' or $kind = 'Enum'">
                            <!-- RTI uses a SafeEnum which requires some magic -->
                            <xsl:value-of select="concat($variable_syntax, '().underlying')" />
                        </xsl:when>
                        <xsl:otherwise>
                            <!-- DDS uses exact case -->
                            <xsl:value-of select="$variable_syntax" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
            
                <xsl:when test="$middleware = 'ospl'">
                    <!-- DDS implementations use get/set via accessors -->
                    <xsl:value-of select="$variable_syntax" />
                </xsl:when>
                <xsl:when test="$middleware = 'tao'">
                    <!-- DDS implementations use get/set via accessors -->
                    <xsl:value-of select="$variable_syntax" />
                </xsl:when>
                <xsl:when test="$middleware = 'base'">
                    <!-- Base uses both get/set functions both via accessors and functions -->
                    <xsl:value-of select="concat('get_', $variable_syntax)" />
                </xsl:when>
                <xsl:when test="$middleware = 'proto'">
                    <!-- Protobuf offers a const ref getter -->
                    <xsl:value-of select="lower-case($variable_syntax)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="cpp:comment_inline(concat('Middleware ', $middleware, ' not implemented'))" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="value">
            <xsl:choose>
                <xsl:when test="$middleware = 'tao' and $is_union = false() ">
                    <xsl:value-of select="concat($obj, $operator, $function_name)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="cpp:invoke_function($obj, $operator, $function_name, '', 0)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$middleware = 'tao' and $node_type = 'String'">
                <!-- String wrap corba strings -->
                <xsl:value-of select="concat('std::string(', $value, ')')" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$value" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:invoke_middleware_add_vector_function" as="xs:string">
        <xsl:param name="obj" as="xs:string"/>
        <xsl:param name="operator" as="xs:string"/>
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="value" as="xs:string" />

        <xsl:variable name="node_kind" select="graphml:get_kind($node)" />
        <xsl:variable name="variable_syntax" select="cdit:get_middleware_variable_syntax($node, $middleware)" />

        <xsl:variable name="vector_child" select="graphml:get_vector_child($node)" />
        <xsl:variable name="vector_kind" select="graphml:get_kind($vector_child)" />

        <xsl:variable name="function_value">
            <xsl:choose>
                <xsl:when test="$middleware = 'base' and $vector_kind = 'AggregateInstance'">
                    <xsl:value-of select="cpp:dereference_var($value)" />
                </xsl:when>
                <xsl:when test="($middleware = 'rti' or $middleware = 'ospl' or $middleware = 'tao')">
                    <xsl:variable name="val">
                        <xsl:if test="$vector_kind = 'AggregateInstance'">
                            <xsl:value-of select="cpp:dereference_var($value)" />
                        </xsl:if>
                        <xsl:if test="$vector_kind != 'AggregateInstance'">
                            <xsl:value-of select="$value" />
                        </xsl:if>
                    </xsl:variable>
                    <xsl:variable name="vector_size" select="cpp:invoke_function(cpp:invoke_function($obj, $operator, $variable_syntax, '', 0), cpp:dot(), 'size', '', 0)" />
                    <xsl:value-of select="cpp:join_args((concat($vector_size, ' + 1'), $val))" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$value" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="function_name">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti' or $middleware = 'ospl' or $middleware = 'tao'">
                    <!-- DDS implementations use set via accessors -->
                    <xsl:value-of select="concat(cpp:invoke_function('', '', $variable_syntax, '', 0), cpp:dot(), 'resize')" />
                </xsl:when>
                <xsl:when test="$middleware = 'base'">
                    <xsl:value-of select="concat(cpp:invoke_function('', '', $variable_syntax, '', 0), cpp:dot(), 'emplace_back')" />
                </xsl:when>
                <xsl:when test="$middleware = 'proto'">
                    <xsl:choose>
                        <xsl:when test="$vector_kind = 'AggregateInstance'">
                            <!-- Vectors with Objects in it can use a mutable_swap function -->
                            <xsl:value-of select="concat(cpp:invoke_function('', '', concat('add_', $variable_syntax), '', 0), cpp:arrow(), 'Swap')" />
                        </xsl:when>
                        <xsl:when test="$vector_kind = 'Member' or $vector_kind = 'EnumInstance'">
                            <!-- Protobuf uses swap for Instances -->
                            <xsl:value-of select="concat('add_', $variable_syntax)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="cpp:comment_inline(concat('Protobuf doesnt support vector with child kind ', o:wrap_quote($vector_kind)))" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="cpp:comment_inline(concat('Middleware ', $middleware, ' not implemented'))" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="cpp:invoke_function($obj, $operator, $function_name, $function_value, 0)" />
    </xsl:function>
    

    <xsl:function name="cdit:invoke_middleware_set_function" as="xs:string">
        <xsl:param name="obj" as="xs:string"/>
        <xsl:param name="operator" as="xs:string"/>
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="value" as="xs:string" />

        <xsl:variable name="node_kind" select="graphml:get_kind($node)" />
        <xsl:variable name="node_type" select="graphml:get_type($node)" />
        <xsl:variable name="parent_node" select="graphml:get_parent_node($node)" />
        <xsl:variable name="is_union" select="graphml:evaluate_data_value_as_boolean($parent_node, 'is_union')" />

        <xsl:variable name="variable_syntax" select="cdit:get_middleware_variable_syntax($node, $middleware)" />

        <xsl:variable name="resolved_value">
            <xsl:choose>
                <xsl:when test="$middleware = 'tao' and $node_type = 'String'">
                    <xsl:value-of select="concat($value, '.c_str()')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$value" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="function_name">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti' or $middleware = 'ospl' or $middleware = 'tao'">
                    <xsl:value-of select="$variable_syntax" />
                </xsl:when>
                 <xsl:when test="$middleware = 'base'">
                    <!-- Base uses both get/set functions both via accessors and functions -->
                    <xsl:value-of select="concat('set_', $variable_syntax)" />
                </xsl:when>
                <xsl:when test="$middleware = 'proto'">
                    <xsl:choose>
                        <xsl:when test="$node_kind = 'AggregateInstance'">
                            <!-- Protobuf uses swap for Instances -->
                            <xsl:value-of select="concat(cpp:invoke_function('', '', concat('mutable_', $variable_syntax), '', 0), cpp:arrow(), 'Swap')" />
                        </xsl:when>
                        <xsl:when test="$node_kind = 'Member' or $node_kind = 'EnumInstance'">
                            <!-- Protobuf implementations use set via functions -->
                            <xsl:value-of select="concat('set_', $variable_syntax)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="cpp:comment_inline(concat('Kind ', $node_kind, ' not implemented'))" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="cpp:comment_inline(concat('Middleware ', $middleware, ' not implemented'))" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$middleware = 'tao' and $is_union = false()">
                <xsl:value-of select="concat($obj, $operator, $function_name, ' = ', $resolved_value)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:invoke_function($obj, $operator, $function_name, $resolved_value, 0)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cpp:get_qualified_type" as="xs:string">
        <xsl:param name="node" as="element()?" />
        <xsl:variable name="kind" select="graphml:get_kind($node)" />
        
        <xsl:choose>    
            <xsl:when test="$kind = 'Member' or $kind = 'Attribute'">
                <xsl:value-of select="cpp:get_member_type($node)" />
            </xsl:when>
            <xsl:when test="$kind = 'VoidType'">
                <xsl:value-of select="'void'" />
            </xsl:when>
            <xsl:when test="$kind = 'Variable'">
                <xsl:variable name="child" select="graphml:get_child_node($node, 1)" />
                <xsl:choose>
                    <xsl:when test="$child">
                        <xsl:value-of select="cpp:get_qualified_type($child)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="cpp:get_member_type($node)" />
                    </xsl:otherwise>
                </xsl:choose> 
            </xsl:when>
            <xsl:when test="$kind = 'EnumInstance'">
                <xsl:value-of select="cpp:get_enum_qualified_type($node, 'base')" />
            </xsl:when>
            <xsl:when test="$kind = 'AggregateInstance' or $kind = 'Aggregate'">
                <xsl:value-of select="cpp:get_aggregate_qualified_type($node, 'base')" />
            </xsl:when>
            <xsl:when test="$kind = 'Vector'">
                <xsl:value-of select="cpp:get_vector_qualified_type($node)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="o:warning(('cpp:get_qualified_type()', 'Node Kind:', o:wrap_quote($kind), 'Not Implemented'))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cpp:get_member_type" as="xs:string">
        <xsl:param name="member" as="element()" />

        <xsl:variable name="type" select="graphml:get_type($member)" />
        <xsl:value-of select="cpp:get_primitive_type($type)" />
    </xsl:function>

    <xsl:function name="cdit:get_enum_type" as="xs:string">
        <xsl:param name="enum" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="enum_definition" select="graphml:get_definition($enum)" />
        <xsl:variable name="enum_namespace" select="graphml:get_namespace($enum_definition)" />
        <xsl:variable name="label" select="o:title_case(graphml:get_label($enum_definition))" />

        <xsl:choose>
            <xsl:when test="cdit:middleware_uses_protobuf($middleware)">
                <xsl:value-of select="o:join_list(($enum_namespace, $label), '_')" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$label" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_enum_member_type" as="xs:string">
        <xsl:param name="enum_member" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="enum_member_label" select="graphml:get_label($enum_member)" />

        <xsl:variable name="var_name">
            <xsl:choose>
                <xsl:when test="cdit:middleware_uses_protobuf($middleware)">
                    <xsl:variable name="enum" select="graphml:get_parent_node($enum_member)" />
                    <xsl:variable name="enum_type" select="cdit:get_enum_type($enum, $middleware)" />
                    <!-- Note that enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children of it. -->
                    <xsl:value-of select="o:join_list(($enum_type, $enum_member_label), '_')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$enum_member_label" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="upper-case($var_name)" />
    </xsl:function>





    <xsl:function name="cdit:get_aggregate_file_prefix" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />


        <xsl:variable name="aggregate_definition" select="graphml:get_definition($aggregate)" />
        <xsl:variable name="namespace" select="graphml:get_namespace($aggregate_definition)" />
        <xsl:variable name="label" select="graphml:get_label($aggregate_definition)" />

        <xsl:variable name="var_name">
            <xsl:choose>
                <xsl:when test="$middleware = 'base'">
                    <xsl:value-of select="$label" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="o:join_list(($namespace, $label), '_')" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="lower-case($var_name)" />
    </xsl:function>

    <xsl:function name="cdit:get_aggregates_middleware_file_name" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="aggregate_label" select="cdit:get_aggregate_file_prefix($aggregate, $middleware)" />

      
        <xsl:variable name="middleware_extension" select="cdit:get_middleware_extension($middleware)" />

        <xsl:value-of select="o:join_list(($aggregate_label, $middleware_extension), '.')" />
    </xsl:function>



    <xsl:function name="cdit:get_middleware_extension" as="xs:string">
        <xsl:param name="middleware" as="xs:string"/>

        <xsl:variable name="middleware_lc" select="lower-case($middleware)" />
        
        <xsl:choose>
            <xsl:when test="$middleware_lc = 'rti' or $middleware_lc = 'ospl' or $middleware_lc = 'tao'">
                <xsl:value-of select="'idl'" />
            </xsl:when>
            <xsl:when test="$middleware_lc = 'proto'">
                <xsl:value-of select="'proto'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('UNKNOWN_MIDDLEWARE_', $middleware)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>



    <xsl:function name="cpp:get_enum_qualified_type" as="xs:string">
        <xsl:param name="enum" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="enum_definition" select="graphml:get_definition($enum)" />

        <xsl:variable name="aggregate" select="graphml:get_parent_node($enum)" />
        <xsl:variable name="aggregate_def" select="graphml:get_definition($aggregate)" />
        <xsl:variable name="enum_namespace" select="graphml:get_namespace($enum_definition)" />
        <xsl:variable name="label" select="cdit:get_enum_type($enum, $middleware)" />

        <xsl:variable name="namespace" as="xs:string*">
            <xsl:choose>
                <xsl:when test="$middleware = 'base'">
                    <xsl:value-of select="cpp:combine_namespaces(('Base', $enum_namespace))" />
                </xsl:when>
                <xsl:when test="cdit:middleware_uses_protobuf($middleware)">
                    <!-- Protobuf Enums are defined within the Aggregates namespace -->
                    <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate_def)" />
                    <xsl:value-of select="$aggregate_namespace" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$enum_namespace" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="suffix" as="xs:string*">
            <xsl:if test="$middleware = 'rti'">
                <!-- DDS implementations use set via accessors -->
                <xsl:value-of select="'inner_enum'" />
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="qualified_type" select="cpp:combine_namespaces(($namespace, $label, $suffix))" />

        <xsl:value-of select="concat('::', $qualified_type)" />
    </xsl:function>

    <xsl:function name="cpp:get_vector_qualified_type" as="xs:string">
        <xsl:param name="vector" as="element()" />

        <xsl:variable name="vector_child" select="graphml:get_vector_child($vector)" />
        <xsl:variable name="child_type" select="cpp:get_qualified_type($vector_child)" />
        <xsl:if test="$child_type != ''">
            <xsl:value-of select="concat('std::vector', o:wrap_angle($child_type))" />
        </xsl:if>
    </xsl:function>

    <xsl:function name="cdit:variablize_value" as="xs:string">
        <xsl:param name="variable" as="xs:string" />
        <xsl:value-of select="if($variable != '') then concat($variable, '_') else ''" />
    </xsl:function>

    <xsl:function name="cdit:get_variable_label" as="xs:string">
        <xsl:param name="label" as="xs:string" />
        <xsl:param name="node" as="element()?" />

        <xsl:variable name="kind" select="graphml:get_kind($node)" />
        <xsl:variable name="parent_node" select="graphml:get_parent_node($node)" />
        <xsl:variable name="parent_kind" select="graphml:get_kind($parent_node)" />

        <xsl:variable name="ancestor_kinds" select="($kind, graphml:get_data_values(graphml:get_ancestor_nodes($node), 'kind'))" />

        <xsl:variable name="prefix">
            <xsl:choose>
                <xsl:when test="$parent_kind = 'Class' or
                                $parent_kind = 'ComponentImpl'">
                    <xsl:value-of select="'g'" />
                </xsl:when>
                <xsl:when test="'InputParameterGroup' = $ancestor_kinds or
                                'InputParameterGroupInstance' = $ancestor_kinds">
                    <xsl:value-of select="'p'" />
                </xsl:when>
                <xsl:when test="$kind = 'AggregateInstance' and
                        ($parent_kind = 'SubscriberPortImpl'
                        )
                        ">
                    <xsl:value-of select="'p'" />
                </xsl:when>
                <xsl:when test="$node">
                    <xsl:value-of select="'m'" />
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="suffix">
            <xsl:choose>
                <xsl:when test="'InputParameterGroupInstance' = $ancestor_kinds or
                                'PublisherPortImpl' = $ancestor_kinds or
                                'RequesterPortImpl' = $ancestor_kinds or
                                'ReturnParameterGroupInstance' = $ancestor_kinds or
                                'Setter' = $kind
                                ">
                    <xsl:value-of select="graphml:get_id($node)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="''" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="o:join_list(($prefix, $label, $suffix), '_')" />
    </xsl:function>


    <xsl:function name="cpp:get_aggregate_type_name" as="xs:string">
        <xsl:param name="aggregate_inst" as="element()" />
        <xsl:variable name="aggregate" select="graphml:get_definition($aggregate_inst)" />
        <xsl:variable name="label" select="o:title_case(graphml:get_label($aggregate))" />
        <xsl:value-of select="$label" />
    </xsl:function>

    <xsl:function name="cpp:get_component_type_name" as="xs:string">
        <xsl:param name="component" as="element()" />

        <xsl:value-of select="cpp:get_aggregate_type_name($component)" />
    </xsl:function>

    <xsl:function name="cpp:get_server_qualified_type" as="xs:string">
        <xsl:param name="server_inst" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="namespace" select="graphml:get_namespace($server_inst)" />
        <xsl:variable name="label" select="cpp:get_aggregate_type_name($server_inst)" />



        <xsl:variable name="combined_namespace" select="cpp:combine_namespaces(($namespace, $label))" />
        <xsl:value-of select="concat('::', 'POA_', $combined_namespace)" />
    </xsl:function>

    <xsl:function name="cpp:get_aggregate_qualified_type" as="xs:string">
        <xsl:param name="aggregate_inst" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="aggregate" select="graphml:get_definition($aggregate_inst)" />

        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        <xsl:variable name="aggregate_label" select="cpp:get_aggregate_type_name($aggregate)" />

        <xsl:variable name="extra_namespace" as="xs:string*">
            <xsl:if test="$middleware = 'base'">
                <xsl:value-of select="'Base'" />
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="combined_namespace" select="cpp:combine_namespaces(($extra_namespace, $aggregate_namespace, $aggregate_label))" />

        <xsl:choose>
            <xsl:when test="$middleware = 'base'">
                <xsl:value-of select="$combined_namespace" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('::', $combined_namespace)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cpp:get_component_qualified_type" as="xs:string">
        <xsl:param name="component" as="element()" />
        
        <xsl:variable name="component_def" select="graphml:get_definition($component)" />
        <xsl:variable name="namespace" select="graphml:get_namespace($component_def)" />
        <xsl:variable name="type" select="cpp:get_component_type_name($component_def)" />
        
        <xsl:value-of select="cpp:combine_namespaces(($namespace, $type))" />
    </xsl:function>
    
    <!-- Converts from the Aggregate Types into primitive CPP types -->
    <xsl:function name="cpp:get_primitive_type" as="xs:string">
        <xsl:param name="type" as="xs:string"  />

        <xsl:choose>
            <xsl:when test="$type = 'String'">
                <xsl:value-of select="'std::string'" />
            </xsl:when>
            <xsl:when test="$type = 'Boolean'">
                <xsl:value-of select="'bool'" />
            </xsl:when>
            <xsl:when test="$type = 'Character'">
                <xsl:value-of select="'char'" />
            </xsl:when>
            <xsl:when test="$type = 'FloatNumber' or $type = 'Float'">
                <xsl:value-of select="'float'" />
            </xsl:when>
            <xsl:when test="$type = 'DoubleNumber' or $type = 'LongDoubleNumber' or $type = 'Double'">
                <xsl:value-of select="'double'" />
            </xsl:when>
            <xsl:when test="$type = 'LongInteger' or $type = 'Integer'">
                <xsl:value-of select="'int'" />
            </xsl:when>
            <xsl:when test="$type = 'UnsignedLongInteger'">
                <xsl:value-of select="'unsigned int'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>Warning: Unknown Type <xsl:value-of select="o:wrap_quote($type)" /></xsl:message>
                <xsl:value-of select="''" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:is_number_type" as="xs:boolean">
        <xsl:param name="type" as="xs:string"  />

        <xsl:value-of select="  $type = 'Boolean' or
                                $type = 'Character' or
                                $type = 'Float' or
                                $type = 'Double' or
                                $type = 'Integer'" />
    </xsl:function>

    <xsl:function name="cdit:compare_nodes_types" as="xs:boolean">
        <xsl:param name="source" as="element()"/>
        <xsl:param name="target" as="element()"/>

        <xsl:variable name="type_1" select="graphml:get_type($source)" />
        <xsl:variable name="type_2" select="graphml:get_type($target)" />

        <xsl:choose>
            <xsl:when test="$type_1 = $type_2">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:when test="cdit:is_number_type($type_1) and cdit:is_number_type($type_2)">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:when test="graphml:get_kind($target) = 'VariadicParameter'">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="false()" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cpp:get_corba_primitive_type" as="xs:string">
        <xsl:param name="type" as="xs:string"  />
        <xsl:choose>
            <xsl:when test="$type = 'short'">
                <xsl:value-of select="'int16_t'" />
            </xsl:when>
            <xsl:when test="$type = 'unsigned short'">
                <xsl:value-of select="'uint16_t'" />
            </xsl:when>
            <xsl:when test="$type = 'long'">
                <xsl:value-of select="'int32_t'" />
            </xsl:when>
            <xsl:when test="$type = 'long long'">
                <xsl:value-of select="'int64_t'" />
            </xsl:when>
            <xsl:when test="$type = 'unsigned long'">
                <xsl:value-of select="'uint32_t'" />
            </xsl:when>
            <xsl:when test="$type = 'unsigned long long'">
                <xsl:value-of select="'uint64_t'" />
            </xsl:when>
            <xsl:when test="$type = 'float' or $type = 'double' or $type = 'char'">
                <xsl:value-of select="$type" />
            </xsl:when>
            <xsl:when test="$type = 'string'">
                <xsl:value-of select="'std::string'" />
            </xsl:when>
            <xsl:when test="$type = 'boolean'">
                <xsl:value-of select="'bool'" />
            </xsl:when>
            <xsl:when test="$type = 'octet'">
                <xsl:value-of select="'uint8_t'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="''" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    

    <xsl:function name="proto:get_aggregate_qualified_type" as="xs:string">
        <xsl:param name="aggregate" as="element()"/>

        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        <xsl:variable name="aggregate_label" select="o:title_case(graphml:get_label($aggregate))" />

        <xsl:choose>
            <xsl:when test="$aggregate_namespace = ''">
                <xsl:value-of select="$aggregate_label" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="o:join_list(($aggregate_namespace, $aggregate_label), '.')" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="idl:get_aggregate_qualified_type" as="xs:string">
        <xsl:param name="aggregate" as="element()"/>

        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        <xsl:variable name="aggregate_label" select="o:title_case(graphml:get_label($aggregate))" />


        <xsl:choose>
            <xsl:when test="$aggregate_namespace = ''">
                <xsl:value-of select="concat('::', $aggregate_label)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:combine_namespaces(($aggregate_namespace, $aggregate_label))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_all_middlewares" as="xs:string*">
        <xsl:sequence select="'zmq'" />
        <xsl:sequence select="'rti'" />
        <xsl:sequence select="'ospl'" />
        <xsl:sequence select="'qpid'" />
        <xsl:sequence select="'tao'" />
    </xsl:function>

    <!--
        Gets utilized middlewares
    -->
    <xsl:function name="cdit:get_deployed_middlewares" as="xs:string*">
        <xsl:param name="entity" as="element(gml:node)" />
        <xsl:param name="generate_all" as="xs:boolean" />
        
        <xsl:variable name="port_instances" select="cdit:get_deployed_port_instances($entity)" />
        <xsl:variable name="middlewares" select="graphml:get_data_values($port_instances, 'middleware')" />

        <xsl:variable name="required_middlewares">
            <xsl:choose>
                <xsl:when test="$generate_all">
                    <xsl:for-each-group select="cdit:get_all_middlewares()" group-by=".">
                        <xsl:sequence select="lower-case(.)" />
                    </xsl:for-each-group>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each-group select="$middlewares" group-by=".">
                        <xsl:sequence select="lower-case(.)" />
                    </xsl:for-each-group>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:sequence select="cdit:parse_middlewares($required_middlewares)" />
    </xsl:function>

     <xsl:function name="cdit:get_deployed_component_instances" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)" />
        
        <xsl:for-each select="graphml:get_descendant_nodes_of_kind($model, 'ComponentInstance')">
            <xsl:if test="graphml:is_deployed(.)">
                <xsl:sequence select="." />
            </xsl:if>
        </xsl:for-each>
    </xsl:function>
    

    <xsl:function name="cdit:get_deployed_port_instances" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)" />
        
        <xsl:variable name="deployed_component_instances" select="cdit:get_deployed_component_instances($model)" />
        <xsl:sequence select="graphml:get_child_nodes_of_kind($deployed_component_instances, ('SubscriberPortInstance', 'PublisherPortInstance', 'RequesterPortInstance', 'ReplierPortInstance'))"/>
    </xsl:function>

    <!--
        Gets the required to generate aggregates for a particular middlewarew
    -->
    <xsl:function name="cdit:get_required_aggregates_for_middleware" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="generate_all" as="xs:boolean" />

        <xsl:variable name="required_aggregates" as="element(gml:node)*">
            <xsl:choose>
                <xsl:when test="$generate_all">
                    <!-- Get All Aggregates -->
                    <xsl:sequence select="graphml:get_descendant_nodes_of_kind($model, 'Aggregate')"/>
                </xsl:when>
                <xsl:otherwise>
                    <!-- Get the Ports -->
                    <xsl:for-each select="cdit:get_deployed_port_instances($model)">
                        <xsl:variable name="port_middleware" select="lower-case(graphml:get_data_value(., 'middleware'))" />
                        
                        <!-- If the middleware we are generating, matches the middleware of the port, we should generate -->
                        <xsl:if test="$middleware = $port_middleware or (cdit:middleware_uses_protobuf($port_middleware) and $middleware='proto') or $middleware = 'base'">
                            <!-- Get all the Aggregate Instances for this particular Port -->
                            <xsl:variable name="definition" select="graphml:get_definition(.)" />
                            <xsl:variable name="aggregate_instances" select="cdit:get_required_aggregates($definition, false())" />

                            <!-- Get all the Definitions used by this aggregate instance -->
                            <xsl:sequence select="$aggregate_instances"/>
                        </xsl:if>
                    </xsl:for-each>

                    <!-- Include the Aggregate Instances required by ComponentImpls For Base -->
                    <xsl:if test="$middleware = 'base'">
                        <xsl:for-each select="cdit:get_deployed_component_instances($model)">
                            <xsl:variable name="component_impl" select="graphml:get_impl(.)" />
                            <xsl:variable name="aggregate_instances" select="cdit:get_required_aggregates($component_impl, false())" />
                            <!-- Get all the Definitions used by this aggregate instance -->
                            <xsl:sequence select="$aggregate_instances" />
                        </xsl:for-each>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:for-each select="graphml:get_definitions($required_aggregates)">
            <xsl:if test="graphml:get_kind(.) = 'Aggregate'">
                <xsl:sequence select="." />
            </xsl:if>
        </xsl:for-each>
    </xsl:function>

    <!--
        Gets the required aggregates for a particular middleware
    -->
    <xsl:function name="cdit:get_required_pubsub_aggregates_for_middleware" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="generate_all" as="xs:boolean" />

        <xsl:variable name="required_aggregates" as="element(gml:node)*">
            <xsl:choose>
                <xsl:when test="$generate_all">
                    <!-- Get All Aggregates -->
                    <xsl:sequence select="graphml:get_descendant_nodes_of_kind($model, 'Aggregate')"/>
                </xsl:when>
                <xsl:otherwise>
                    <!-- Get the Ports -->
                    <xsl:for-each select="cdit:get_deployed_port_instances($model)">
                        <xsl:variable name="port_middleware" select="lower-case(graphml:get_data_value(., 'middleware'))" />

                        <!-- If the middleware we are generating, matches the middleware of the port, we should generate -->
                        <xsl:if test="$middleware = $port_middleware">
                            <!-- Get all the Aggregate Instances for this particular Port -->
                            <xsl:variable name="definition" select="graphml:get_definition(.)" />
                            <xsl:variable name="aggregate_instances" select="graphml:get_child_nodes_of_kind($definition, 'AggregateInstance')" />

                            <!-- Get all the Definitions used by this aggregate instance -->
                            <xsl:sequence select="$aggregate_instances"/>
                        </xsl:if>
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:for-each select="graphml:get_definitions($required_aggregates)">
            <xsl:if test="graphml:get_kind(.) = 'Aggregate'">
                <xsl:sequence select="." />
            </xsl:if>
        </xsl:for-each>
    </xsl:function>

    <!--
        Gets the required ServerInterface's for a particular middleware
    -->
    <xsl:function name="cdit:get_required_serverinterfaces_for_middleware" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="generate_all" as="xs:boolean" />

        <xsl:variable name="required_instances" as="element(gml:node)*">
            <xsl:choose>
                <xsl:when test="$generate_all">
                    <!-- Get All Aggregates -->
                    <xsl:sequence select="graphml:get_descendant_nodes_of_kind($model, 'ServerInterface')"/>
                </xsl:when>
                <xsl:otherwise>
                    <!-- Get the Ports -->
                    <xsl:for-each select="cdit:get_deployed_port_instances($model)">
                        <xsl:variable name="port_middleware" select="lower-case(graphml:get_data_value(., 'middleware'))" />

                        <!-- If the middleware we are generating, matches the middleware of the port, we should generate -->
                        <xsl:if test="$middleware = $port_middleware">
                            <!-- Get all the Aggregate Instances for this particular Port -->
                            <xsl:variable name="definition" select="graphml:get_definition(.)" />
                            <xsl:variable name="port_type" select="graphml:get_port_aggregate($definition)" />
                            <xsl:variable name="port_kind" select="graphml:get_kind($port_type)" />
                            <xsl:if test="$port_kind = 'ServerInterface'">
                                <xsl:sequence select="$port_type" />
                            </xsl:if>
                        </xsl:if>
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:sequence select="graphml:get_definitions($required_instances)" />
    </xsl:function>

    

    <!--
        Gets the Ports Definitions of the aggregate provided
    -->
    <xsl:function name="cdit:get_eventports_for_aggregate" as="element(gml:node)*">
        <xsl:param name="aggregate" as="element(gml:node)?" />
        
        <xsl:variable name="model" select="graphml:get_ancestor_nodes_of_kind($aggregate, 'Model')" />
        
        <xsl:for-each select="graphml:get_descendant_nodes_of_kind($model, ('PublisherPort', 'SubscriberPort'))">
            <xsl:variable name="aggregate_instance" select="graphml:get_child_node(., 1)" />
            <xsl:variable name="aggregate_definition" select="graphml:get_definition($aggregate_instance)" />

            <xsl:if test="$aggregate_definition = $aggregate">
                <xsl:sequence select="."/>
            </xsl:if>
        </xsl:for-each>
    </xsl:function>

    



    <xsl:function name="cdit:parse_middlewares" as="xs:string*">
        <xsl:param name="middlewares" as="xs:string*"/>
        
        
        <xsl:variable name="sanitized_mw" select="normalize-space(lower-case($middlewares))" />

        <xsl:variable name="token_middlewares" as="xs:string*">
            <xsl:for-each select="tokenize($sanitized_mw, ' ')">
                <xsl:sequence select="." />
                <xsl:if test=". = 'zmq'">
                    <xsl:sequence select="'proto'" />
                </xsl:if>
                <xsl:if test=". = 'qpid'">
                    <xsl:sequence select="'proto'" />
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>

        <xsl:sequence select="distinct-values(($token_middlewares, 'base'))"/>
    </xsl:function>

    <xsl:function name="cdit:parse_components" as="xs:string*">
        <xsl:param name="components" as="xs:string*"/>

        <xsl:variable name="token_middlewares" select="tokenize(normalize-space(lower-case($components)), ',')" />
        <xsl:sequence select="distinct-values($token_middlewares)"/>
    </xsl:function>

    <xsl:function name="cdit:get_components_path" as="xs:string">
        <xsl:param name="component" as="element()" />
        <xsl:value-of select="cdit:get_aggregates_path($component)" />
    </xsl:function>

    <xsl:function name="cdit:get_aggregates_path" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="aggregate_label" select="graphml:get_label($aggregate)" />
        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        
        <xsl:value-of select="lower-case(o:join_paths(($aggregate_namespace, $aggregate_label)))" />
    </xsl:function>

    <xsl:function name="cdit:get_server_interface_path" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="aggregate_label" select="graphml:get_label($aggregate)" />
        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        
        <xsl:value-of select="lower-case(o:join_paths(($aggregate_namespace, $aggregate_label)))" />
    </xsl:function>

    <xsl:function name="cdit:get_base_aggregates_cpp_path" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="path" select="cdit:get_aggregates_path($aggregate)" />
        <xsl:variable name="file" select="cdit:get_base_aggregate_cpp_name($aggregate)" />
        <xsl:value-of select="o:join_paths(($path, $file))" />
    </xsl:function>

    <xsl:function name="cdit:get_base_aggregate_h_name" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="aggregate_label" select="lower-case(graphml:get_label($aggregate))" />
        <xsl:value-of select="concat($aggregate_label,'.h')" />
    </xsl:function>

    <xsl:function name="cdit:get_base_aggregate_cpp_name" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="aggregate_label" select="lower-case(graphml:get_label($aggregate))" />
        <xsl:value-of select="concat($aggregate_label,'.cpp')" />
    </xsl:function>

    <xsl:function name="cdit:get_aggregate_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="path" select="cdit:get_aggregates_path($aggregate)" />
        <xsl:value-of select="lower-case(o:join_paths(('datatypes', $middleware, $path)))" />
    </xsl:function>

    <xsl:function name="cdit:get_pubsub_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="path" select="cdit:get_aggregates_path($aggregate)" />
        <xsl:value-of select="lower-case(o:join_paths(('ports', 'pubsub', $middleware, $path)))" />
    </xsl:function>

    <xsl:function name="cdit:get_reqrep_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="path" select="cdit:get_aggregates_path($server_interface)" />
        <xsl:value-of select="lower-case(o:join_paths(('ports', 'requestreply', $middleware, $path)))" />
    </xsl:function>


    <xsl:function name="cdit:get_component_path" as="xs:string">
        <xsl:param name="component" as="element()" />

        <xsl:variable name="path" select="cdit:get_components_path($component)" />
        <xsl:value-of select="lower-case(o:join_paths(('components', $path)))" />
    </xsl:function>

    <xsl:function name="cdit:get_aggregate_h_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="path" select="cdit:get_aggregate_path($middleware, $aggregate)" />
        <xsl:variable name="file" select="cdit:get_base_aggregate_h_name($aggregate)" />
        <xsl:value-of select="o:join_paths(($path, $file))" />
    </xsl:function>

    <xsl:function name="cdit:get_base_enum_h_path" as="xs:string">
        <xsl:param name="enum" as="element()" />

        <xsl:variable name="path" select="cdit:get_aggregate_path('Base', $enum)" />
        <xsl:variable name="file" select="cdit:get_base_aggregate_h_name($enum)" />
        <xsl:value-of select="o:join_paths(('enums', $path, $file))" />
    </xsl:function>

    <!-- Get all required aggregates -->
    <xsl:function name="cdit:get_required_aggregates" as="element()*">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="ignore_nested" as="xs:boolean" />
        
        <!-- Get All Aggregates Used in this entity -->
        <xsl:variable name="aggregate_definitions" select="graphml:get_definitions(graphml:get_descendant_nodes_of_kind($aggregate, 'AggregateInstance'))" />

        <xsl:variable name="ignored_definitions" as="element()*">
            <xsl:if test="$ignore_nested">
                <xsl:sequence select="graphml:get_definitions($aggregate_definitions/graphml:get_descendant_nodes_of_kind(., 'AggregateInstance'))" />
            </xsl:if>
        </xsl:variable>
        
        <!-- Return the Aggregates Required, which are not nested -->
         <xsl:for-each select="$aggregate_definitions except $ignored_definitions">
            <xsl:if test="graphml:get_kind(.) = 'Aggregate'">
                <xsl:sequence select="." />
            </xsl:if>
        </xsl:for-each>
    </xsl:function>

    <!-- Get all required aggregates -->
    <xsl:function name="cdit:get_required_enums" as="element()*">
        <xsl:param name="entity" as="element()" />
        
        <!-- Get All Aggregates Used in this entity -->
        <xsl:variable name="enum_definitions" select="graphml:get_definitions(graphml:get_descendant_nodes_of_kind($entity, 'EnumInstance'))" />


        <xsl:variable name="ignored_definitions" as="element()*">
            <xsl:for-each select="cdit:get_required_aggregates($entity, false())">
                <xsl:sequence select="cdit:get_required_enums(.)" />
            </xsl:for-each>
        </xsl:variable>
        
        <!-- Return the Aggregates Required, which are not nested -->
        <xsl:sequence select="$enum_definitions except $ignored_definitions" />
    </xsl:function>

    <xsl:function name="cdit:get_function_name" as="xs:string">
        <xsl:param name="port" as="element()"/>
        <xsl:variable name="port_def" select="graphml:get_definition($port)" />
        <xsl:variable name="def_kind" select="graphml:get_kind($port_def)" />
        <xsl:variable name="def_label" select="graphml:get_label($port_def)" />
        
        <xsl:variable name="port_label" select="graphml:get_label($port)" />
        <xsl:variable name="port_kind" select="graphml:get_kind($port)" />

        <xsl:variable name="prefix">
            <xsl:choose>
                <xsl:when test="$def_kind = 'SubscriberPort'">
                    <xsl:value-of select="'Sub'" />
                </xsl:when>
                <xsl:when test="$def_kind = 'PublisherPort'">
                    <xsl:value-of select="'Pub'" />
                </xsl:when>
                <xsl:when test="$port_kind = 'ReplierPort' or $port_kind = 'ReplierPortImpl'">
                    <xsl:value-of select="'Rep'" />
                </xsl:when>
                <xsl:when test="$port_kind = 'RequesterPort' or $port_kind = 'RequesterPortImpl'">
                    <xsl:value-of select="'Req'" />
                </xsl:when>
                <xsl:when test="$def_kind = 'PeriodicPort'">
                    <xsl:value-of select="'Periodic'" />
                </xsl:when>
                <xsl:when test="$def_kind = 'Function'">
                    <xsl:value-of select="'Fn'" />
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="label">
            <xsl:choose>
                <xsl:when test="$def_kind = 'ServerInterface' ">
                    <xsl:value-of select="$port_label" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$def_label" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="o:join_list(($prefix, $label), '_')" />
    </xsl:function>
    

    <xsl:function name="cdit:comment_graphml_node">
        <xsl:param name="element" as="element()" />
        <xsl:param name="tab" as="xs:integer" />

        <xsl:if test="$debug_mode">
            <xsl:value-of select="cpp:comment((o:wrap_square(graphml:get_kind($element)), graphml:get_label($element), o:wrap_angle(graphml:get_id($element))), $tab)" />
        </xsl:if>
    </xsl:function>


    <xsl:function name="cdit:get_default_primitive_value">
        <xsl:param name="type" as="xs:string" />
        <xsl:choose>
            <xsl:when test="$type = 'String'">
                <xsl:value-of select="o:wrap_dblquote('')"/>
            </xsl:when>
            <xsl:when test="$type = 'Boolean'">
                <xsl:value-of select="'false'"/>
            </xsl:when>
            <xsl:when test="$type = 'Double' or $type = 'Float'">
                <xsl:value-of select="'0.0'"/>
            </xsl:when>
            <xsl:when test="$type = 'Integer' or $type = 'Character'">
                <xsl:value-of select="'0'"/>
            </xsl:when>
        </xsl:choose>
    </xsl:function>

    

    <xsl:function name="cdit:declare_custom_function">
        <xsl:param name="function" as="element()" />
        <xsl:param name="tab" as="xs:integer" />

        <xsl:variable name="name" select="cdit:get_function_name($function)" />
        <xsl:variable name="return_parameter" select="cdit:get_function_return_parameter_declarations($function)" />
        <xsl:variable name="input_parameters" select="cdit:get_function_input_parameter_declarations($function)" />
        
        <xsl:value-of select="cdit:comment_graphml_node($function, $tab)" />
        <xsl:value-of select="cpp:declare_function($return_parameter, $name, $input_parameters, ';', $tab)" />
    </xsl:function>

    <xsl:function name="cdit:get_variable_name">
        <xsl:param name="node" as="element()?"/>
        <xsl:variable name="kind" select="graphml:get_kind($node)" />
        <xsl:variable name="label" select="lower-case(graphml:get_label($node))" />
        <xsl:variable name="parent_kind" select="graphml:get_kind(graphml:get_parent_node($node))" />

        <xsl:choose>
            <xsl:when test="$kind = 'FunctionCall'">
                <xsl:variable name="worker_function_inst" select="graphml:get_first_definition($node)" />
                <xsl:variable name="worker_inst" select="graphml:get_parent_node($worker_function_inst)" />
                <!-- Select Our worker as our variable_name -->
                <xsl:if test="not(graphml:is_descendant_of($worker_inst, $node))">
                    <xsl:value-of select="cdit:get_variable_name($worker_inst)"/>
                </xsl:if>
            </xsl:when>            
            <xsl:when test="$kind = 'VoidType'">
                <xsl:value-of select="''"/>
            </xsl:when>
            <xsl:when test="$kind = 'Setter'">
                <xsl:value-of select="cdit:get_variable_label($kind, $node)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cdit:get_variable_label($label, $node)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    
    <xsl:function name="cdit:declare_variable">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="tab" as="xs:integer" />
         
        <xsl:variable name="label" select="graphml:get_label($aggregate)" />
        <xsl:variable name="kind" select="graphml:get_kind($aggregate)" />
        <xsl:variable name="cpp_type" select="cpp:get_qualified_type($aggregate)" />
        <xsl:variable name="var_label" select="cdit:get_variable_name($aggregate)" />
        <xsl:variable name="set_value" select="graphml:get_data_value($aggregate, 'value')" />

        <xsl:variable name="value">
            <xsl:choose>
                <xsl:when test="$set_value != ''">
                    <xsl:value-of select="$set_value" />
                </xsl:when>
                <xsl:when test="$kind = 'EnumInstance'">
                    <xsl:variable name="enum_def" select="graphml:get_definition($aggregate)" />
                    <xsl:variable name="enum_member" select="graphml:get_child_node($enum_def, 1)" />
                    <xsl:if test="$enum_member">
                        <xsl:value-of select="cdit:get_resolved_enum_member_type($enum_member)" />
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$kind = 'MemberInstance' or $kind = 'Member' or $kind = 'Variable'">
                    <xsl:variable name="member_def" select="graphml:get_definition($aggregate)" />
                    <xsl:variable name="member_type" select="graphml:get_type($member_def)" />
                    <xsl:variable name="child" select="graphml:get_child_node($member_def, 1)" />
                    <xsl:if test="not($child)">
                        <xsl:value-of select="cdit:get_default_primitive_value($member_type)" />
                    </xsl:if>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="cpp:define_variable($cpp_type, $var_label, $value, cpp:nl(), $tab)" />

    </xsl:function>

    <xsl:function name="cdit:declare_datatype_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="tab" as="xs:integer" />
        
        <xsl:variable name="label" select="graphml:get_label($aggregate)" />
        <xsl:variable name="kind" select="graphml:get_kind($aggregate)" />
        <xsl:variable name="cpp_type" select="cpp:get_qualified_type($aggregate)" />
        <xsl:variable name="var_label" select="cdit:get_variable_name($aggregate)" />
        <xsl:variable name="set_value" select="graphml:get_data_value($aggregate, 'value')" />
        
        <xsl:choose>
            <xsl:when test="$cpp_type != ''">
                <!-- Public Declarations -->
                <xsl:value-of select="cpp:public($tab)" />
                <xsl:value-of select="cdit:comment_graphml_node($aggregate, $tab + 1)" />
                <xsl:value-of select="cpp:declare_function('void', concat('set_', $label), cpp:const_ref_var_def($cpp_type, 'value'), ';', $tab + 1)" />
                <xsl:value-of select="cpp:declare_function(cpp:const_ref_var_def($cpp_type, ''), concat('get_', $label), '', ' const;', $tab + 1)" />
                <xsl:value-of select="cpp:declare_function(cpp:ref_var_def($cpp_type, ''), $label, '', ';', $tab + 1)" />
                <!-- Private Declarations -->
                <xsl:value-of select="cpp:private($tab)" />
                <xsl:choose>
                    <xsl:when test="$kind != 'Attribute'">
                        <xsl:value-of select="cdit:declare_variable($aggregate, $tab + 1)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="cpp:declare_variable(cpp:shared_ptr('Attribute'), $var_label, cpp:nl(), $tab + 1)" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cdit:comment_graphml_node($aggregate, $tab)" />
                <xsl:value-of select="cpp:comment('Cannot find valid CPP type for this element', $tab)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_union_descrimantor_type">
        <xsl:param name="aggregate" as="element()" />
        <xsl:variable name="label" select="graphml:get_label($aggregate)" />
        <xsl:value-of select="concat(o:title_case($label), 'Descriminator')" />
    </xsl:function>

    <xsl:function name="cdit:get_qualified_union_descrimantor_type">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:choose>
            <xsl:when test="$middleware = 'base'">
                <xsl:variable name="aggregate_type" select="cpp:get_aggregate_qualified_type($aggregate, $middleware)" />
                <xsl:variable name="descriminator_enum_type" select="cdit:get_union_descrimantor_type($aggregate)" />
                <xsl:value-of select="cpp:combine_namespaces(($aggregate_type, $descriminator_enum_type))" />
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="namespace" select="graphml:get_namespace($aggregate)" />
            <xsl:variable name="aggregate_label" select="cpp:get_aggregate_type_name($aggregate)" />
            <xsl:variable name="descriminator_enum_type" select="concat(cdit:get_union_descrimantor_type($aggregate), '_def')" />

            <xsl:variable name="enum_type" select="o:join_list(($namespace, $descriminator_enum_type), '_')" />
            <xsl:value-of select="concat('::', cpp:combine_namespaces(($namespace, $enum_type)))" />
          </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    

    

    <xsl:function name="cdit:declare_union_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="tab" as="xs:integer" />


        <xsl:variable name="descriminator_enum_type" select="cdit:get_union_descrimantor_type($aggregate)" />
        <xsl:variable name="descriminator_type" select="$descriminator_enum_type" />
        <xsl:variable name="descriminator_var" select="'descriminator_'" />
        <xsl:variable name="unset_enum" select="'UNSET'" />


        <!-- Public Declarations -->
        <xsl:value-of select="cpp:public($tab)" />
        <xsl:value-of select="cpp:comment('Union Descriminator', $tab + 1)" />

        <!-- Define the Enum -->
        <xsl:value-of select="cpp:enum($descriminator_enum_type, $tab + 1)" />
        
        <xsl:value-of select="cpp:enum_value($unset_enum, 0, false(), $tab + 2)" />
        <xsl:for-each select="graphml:get_child_nodes($aggregate)">
            <xsl:variable name="member_label" select="upper-case(graphml:get_label(.))" />
            <xsl:value-of select="cpp:enum_value($member_label, position(), position() = last(), $tab + 2)" />
        </xsl:for-each>
        <xsl:value-of select="cpp:scope_end($tab + 1)" />
        
        <xsl:value-of select="cpp:declare_function($descriminator_type, 'get_descriminator', '', ' const;', $tab + 1)" />

        <!-- Protected Declarations -->
        <xsl:value-of select="cpp:protected($tab)" />
        <xsl:value-of select="cpp:declare_function('void', 'set_descriminator', cpp:define_variable($descriminator_type, 'descriminator', '', '', 0), ';', $tab + 1)" />
        
        <!-- Private Declarations -->
        <xsl:value-of select="cpp:private($tab)" />
        <xsl:value-of select="cpp:define_variable($descriminator_type, $descriminator_var, cpp:combine_namespaces(($descriminator_type, $unset_enum)), cpp:nl(), $tab + 1)" />
    </xsl:function>

    <xsl:function name="cdit:define_union_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="class_name" as="xs:string" />
        

        <xsl:variable name="descriminator_enum_type" select="cpp:combine_namespaces(($class_name, cdit:get_union_descrimantor_type($aggregate)))" />
        <xsl:variable name="descriminator_type" select="$descriminator_enum_type" />
        <xsl:variable name="descriminator_var" select="'descriminator_'" />

        <!-- Getter -->
        <xsl:value-of select="cpp:define_function($descriminator_type, $class_name, 'get_descriminator', '', concat(' const', cpp:scope_start(0)))" />
        <xsl:value-of select="cpp:return($descriminator_var, 1)" />
        <xsl:value-of select="cpp:scope_end(0)" />
        <xsl:value-of select="o:nl(1)" />

        <!-- Setter -->
        <xsl:value-of select="cpp:define_function('void', $class_name, 'set_descriminator', o:join_list(($descriminator_type, 'descriminator'), ' '), cpp:scope_start(0))" />
        <xsl:value-of select="cpp:define_variable('', $descriminator_var, 'descriminator', cpp:nl(), 1)" />
        <xsl:value-of select="cpp:scope_end(0)" />
        <xsl:value-of select="o:nl(1)" />
    </xsl:function>

    <xsl:function name="cdit:define_datatype_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="element" as="element()" />
        <xsl:param name="class_name" as="xs:string" />
        
        <xsl:variable name="label" select="graphml:get_label($element)" />
        <xsl:variable name="cpp_type" select="cpp:get_qualified_type($element)" />
        <xsl:variable name="var_label" select="cdit:get_variable_name($element)" />
        <xsl:variable name="kind" select="graphml:get_kind($element)" />

        <xsl:variable name="is_attribute" select="$kind = 'Attribute'" />

        <xsl:variable name="is_union" select="graphml:evaluate_data_value_as_boolean($aggregate, 'is_union')" />
        <xsl:variable name="descriminator_enum_type" select="cdit:get_union_descrimantor_type($aggregate)" />
        <xsl:variable name="enum_val" select="cpp:combine_namespaces(($descriminator_enum_type, upper-case($label)))" />
        <xsl:variable name="notset_enum_val" select="cpp:combine_namespaces(($descriminator_enum_type, 'UNSET'))" />
        <xsl:variable name="descriminator_var" select="'descriminator_'" />
        

        <xsl:if test="$cpp_type != ''">
                <!-- Define Setter Function -->
                <xsl:value-of select="cpp:define_function('void', $class_name, concat('set_', $label), cpp:const_ref_var_def($cpp_type, 'value'), cpp:scope_start(0))" />
                    <xsl:choose>
                        <xsl:when test="$is_attribute">
                            <xsl:value-of select="cpp:invoke_function($var_label, cpp:arrow(), cdit:get_attribute_set_function($element), 'value', 1)" />
                            <xsl:value-of select="cpp:nl()" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$is_union">
                                <xsl:value-of select="cpp:comment('Set the union descriminator on set', 1)" />
                                <xsl:value-of select="cpp:invoke_function('', '', 'set_descriminator', $enum_val, 1)" />
                                <xsl:value-of select="cpp:nl()" />
                            </xsl:if>
                            <xsl:value-of select="cpp:define_variable('', $var_label, 'value', cpp:nl(), 1)" />
                        </xsl:otherwise>
                    </xsl:choose>
                <xsl:value-of select="cpp:scope_end(0)" />
                <xsl:value-of select="o:nl(1)" />

                <!-- Define Getter Function -->
                <xsl:value-of select="cpp:define_function(cpp:const_ref_var_def($cpp_type, ''), $class_name, concat('get_', $label), '', concat(' const', cpp:scope_start(0)))" />
                    <xsl:choose>
                        <xsl:when test="$is_attribute">
                            <xsl:variable name="get_var" select="cpp:invoke_function($var_label, cpp:arrow(), cdit:get_attribute_ref_function($element), '', 0)" />
                            <xsl:value-of select="cpp:return($get_var, 1)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$is_union">
                                <xsl:value-of select="cpp:if_not(o:join_list(($descriminator_var, '==', $enum_val), ' '), cpp:scope_start(0), 1)" />
                                    <xsl:value-of select="cpp:cerr(o:wrap_dblquote(concat(o:wrap_quote(concat($class_name, '::get_', $label)), ': Descriminator is not set as: ', $enum_val)), 2)" />
                                <xsl:value-of select="cpp:scope_end(1)" />
                            </xsl:if>
                           
                            <xsl:value-of select="cpp:return($var_label, 1)" />
                        </xsl:otherwise>
                    </xsl:choose>
                <xsl:value-of select="cpp:scope_end(0)" />
                <xsl:value-of select="o:nl(1)" />

                <!-- Define Ref Getter Function -->
                <xsl:value-of select="cpp:define_function(cpp:ref_var_def($cpp_type, ''), $class_name, $label, '', cpp:scope_start(0))" />
                    <xsl:choose>
                        <xsl:when test="$is_attribute">
                            <xsl:variable name="get_var" select="cpp:invoke_function($var_label, cpp:arrow(), cdit:get_attribute_ref_function($element), '', 0)" />
                            <xsl:value-of select="cpp:return($get_var, 1)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$is_union">
                                <xsl:value-of select="cpp:if_not(o:join_list(($descriminator_var, '==', $enum_val, cpp:or(), $descriminator_var, '==', $notset_enum_val), ' '), cpp:scope_start(0), 1)" />
                                    <xsl:value-of select="cpp:cerr(o:wrap_dblquote(concat(o:wrap_quote(concat($class_name, '::', $label)), ': Descriminator is not set as: ', $enum_val)), 2)" />
                                <xsl:value-of select="cpp:scope_end(1)" />

                                <xsl:value-of select="cpp:comment('Set the union descriminator on set', 1)" />
                                <xsl:value-of select="cpp:invoke_function('', '', 'set_descriminator', $enum_val, 1)" />
                                <xsl:value-of select="cpp:nl()" />
                            </xsl:if>
                            <xsl:value-of select="cpp:return($var_label, 1)" />
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:value-of select="cpp:scope_end(0)" />
                <xsl:value-of select="o:nl(1)" />
            </xsl:if>
    </xsl:function>

    <xsl:function name="cdit:get_attribute_enum_type" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="cpp:combine_namespaces(('ATTRIBUTE_TYPE', upper-case(graphml:get_type($attribute))))" />
    </xsl:function>	

    <xsl:function name="cdit:get_attribute_set_function" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="o:join_list(('set', graphml:get_type($attribute)), '_')" />
    </xsl:function>	

    <xsl:function name="cdit:get_attribute_get_function" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="o:join_list(('get', graphml:get_type($attribute)), '_')" />
    </xsl:function>

    <xsl:function name="cdit:get_attribute_ref_function" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="graphml:get_type($attribute)" />
    </xsl:function>

    <xsl:function name="cdit:get_unique_class" as="element()*">
        <xsl:param name="component_impl" as="element()"  />

        <xsl:variable name="classes" select="graphml:get_child_nodes_of_kind($component_impl, 'ClassInstance')" />

        <xsl:for-each-group select="$classes" group-by="graphml:get_definition(.)">
            <xsl:variable name="worker" select="graphml:get_data_value(., 'worker')" />

            <xsl:choose>
                <!-- Ignore Vector Operations -->
                <xsl:when test="$worker = 'Vector_Operations'" />
                <xsl:otherwise>
                    <xsl:sequence select="." />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each-group>
    </xsl:function>

    <xsl:function name="cdit:get_class_type" as="xs:string">
        <xsl:param name="class" as="element()"  />

        <xsl:choose>
            <xsl:when test="graphml:is_class_instance_worker($class)">
                <!-- Is Worker -->
                <xsl:value-of select="graphml:get_type($class)" />
            </xsl:when>
            <xsl:otherwise>
                <!-- Is Custom Class -->
                <xsl:value-of select="o:title_case(graphml:get_type($class))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_qualified_class_type" as="xs:string">
        <xsl:param name="class" as="element()"  />

        <xsl:variable name="definition" select="graphml:get_definition($class)" />
        <xsl:variable name="namespace" select="graphml:get_namespace($definition)" />
        <xsl:variable name="type" select="cdit:get_class_type($class)" />

        <xsl:value-of select="cpp:combine_namespaces(($namespace, $type))" />
    </xsl:function>

    <xsl:function name="cdit:define_class_variable" as="xs:string*">
        <xsl:param name="class" as="element()"  />
        <xsl:param name="tab" as="xs:integer"  />

        <xsl:variable name="type" select="cdit:get_qualified_class_type($class)" />
        <xsl:variable name="label" select="graphml:get_data_value($class, 'label')" />
        <xsl:variable name="variable" select="cdit:get_variable_name($class)" />

        <xsl:variable name="getter" select="cpp:invoke_templated_static_function($type, 'AddTypedWorker', o:wrap_dblquote($label), '', 0)" />

        <xsl:value-of select="cdit:comment_graphml_node($class, $tab)" />
        <xsl:value-of select="cpp:define_variable('', $variable, $getter, cpp:nl(), $tab)" />
    </xsl:function>

    <xsl:function name="cdit:declare_class_variable" as="xs:string*">
        <xsl:param name="class" as="element()"  />
        <xsl:param name="tab" as="xs:integer"  />

        <xsl:variable name="type" select="cdit:get_qualified_class_type($class)" />
        <xsl:variable name="label" select="graphml:get_data_value($class, 'label')" />
        <xsl:variable name="variable" select="cdit:get_variable_name($class)" />

        <xsl:value-of select="cdit:comment_graphml_node($class, $tab)" />
        <xsl:value-of select="cpp:declare_variable(cpp:shared_ptr($type), $variable, cpp:nl(), $tab)" />
    </xsl:function>



    <xsl:function name="cdit:get_worker_path" as="xs:string">
        <xsl:param name="worker" as="element()"  />
        <xsl:variable name="worker_folder" select="lower-case(graphml:get_data_value($worker, 'folder'))" />
        
        <xsl:variable name="rel_folder" select="replace($worker_folder, '\$\{re_path\}/src/', '')" />
        <xsl:value-of select="$rel_folder" />
    </xsl:function>

    <xsl:function name="cdit:get_class_worker_type" as="xs:string">
        <xsl:param name="class" as="element()"  />

        <xsl:variable name="class_def" select="graphml:get_definition($class)" />
        <xsl:value-of select="graphml:get_data_value($class_def, 'worker')" />
    </xsl:function>

    <xsl:function name="cdit:is_class_worker" as="xs:boolean">
        <xsl:param name="class" as="element()"  />

        <xsl:variable name="class_def" select="graphml:get_definition($class)" />
        <xsl:value-of select="graphml:got_data($class_def, 'worker')" />
    </xsl:function>

    <xsl:function name="cdit:get_class_header" as="xs:string">
        <xsl:param name="class" as="element()"  />

        <xsl:variable name="class_def" select="graphml:get_definition($class)" />

        <xsl:variable name="worker_name" select="graphml:get_data_value($class_def, 'worker')" />
        <xsl:choose>
            <xsl:when test="$worker_name = 'Vector_Operations'">
                <xsl:value-of select="''" />
            </xsl:when>
            <xsl:when test="$worker_name != ''">
                <xsl:variable name="worker_file" select="lower-case(graphml:get_data_value($class_def, 'file'))" />
                <xsl:value-of select="o:join_paths((cdit:get_worker_path($class_def), concat($worker_file, '.h')))" />
            </xsl:when>
            <xsl:otherwise>
                <!-- TODO DO EXTERNAL CLASS REFERENCE -->
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_resolved_enum_member_type" as="xs:string">
        <xsl:param name="enum_member" as="element()"/>

        <xsl:variable name="member_label" select="upper-case(graphml:get_label($enum_member))" />
        <xsl:variable name="enum" select="graphml:get_parent_node($enum_member)" />
        <xsl:variable name="enum_namespaces" select="o:trim_list(('Base', graphml:get_namespace($enum)))" />
        <xsl:variable name="enum_label" select="o:title_case(graphml:get_label($enum))" />

        <xsl:value-of select="cpp:combine_namespaces(($enum_namespaces, $enum_label, $member_label))" />
    </xsl:function>


    
    <xsl:function name="cmake:setup_re_path">
        <xsl:value-of select="cmake:comment('CDIT Runtime Paths', 0)" />
        <xsl:value-of select="cmake:set_variable('RE_PATH', cmake:get_env_var('RE_PATH'), 0)" />
        <xsl:value-of select="cmake:set_variable('CMAKE_MODULE_PATH', o:join_paths((cmake:wrap_variable('RE_PATH'), 'cmake_modules')), 0)" />
        <xsl:value-of select="o:nl(1)" />
    </xsl:function>

    <xsl:function name="cdit:get_top_cmake">
        <xsl:value-of select="cmake:cmake_minimum_required('3.1')" />
        <xsl:value-of select="cmake:set_cpp11()" />
        <xsl:value-of select="cmake:setup_re_path()" />

        <xsl:variable name="lib_dir" select="o:join_paths((cmake:current_source_dir_var(), 'lib'))" />

        <xsl:value-of select="cmake:set_library_output_directory($lib_dir)" />
        <xsl:value-of select="cmake:set_archive_output_directory($lib_dir)" />
        
        <xsl:value-of select="cmake:add_subdirectories(('components', 'ports', 'classes', 'datatypes'))" />
    </xsl:function>

    <xsl:function name="cdit:middleware_requires_topic" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>

        <xsl:variable name="middleware_lc" select="lower-case($middleware)" />

        <xsl:value-of select="$middleware_lc='qpid' or $middleware_lc='rti' or $middleware_lc='ospl'" />
   </xsl:function>

   <xsl:function name="cdit:middlewares_match" as="xs:boolean">
        <xsl:param name="middleware1" as="xs:string"/>
        <xsl:param name="middleware2" as="xs:string"/>

        <xsl:variable name="middleware1_lc" select="lower-case($middleware1)" />
        <xsl:variable name="middleware2_lc" select="lower-case($middleware2)" />

        <xsl:choose>
            <xsl:when test="$middleware1_lc = $middleware2_lc">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:when test="($middleware1_lc = 'rti' or $middleware1_lc = 'ospl') and ($middleware2_lc = 'ospl' or $middleware2_lc = 'rti')">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="false()" />
            </xsl:otherwise>
        </xsl:choose>
   </xsl:function>

 <xsl:function name="cdit:get_function_input_parameter_declarations" as="xs:string*">
        <xsl:param name="node" as="element()"/>

        <xsl:variable name="input_parameter_group" select="graphml:get_child_nodes_of_kind($node, ('InputParameterGroup', 'InputParameterGroupInstance'))" />

        <xsl:variable name="resolved_args" as="xs:string*">
            <xsl:for-each select="graphml:get_child_nodes($input_parameter_group[1])">
                <xsl:variable name="cpp_type" select="cpp:get_qualified_type(.)" />
                <xsl:variable name="var_label" select="cdit:get_variable_name(.)" />
                <xsl:if test="$cpp_type and $cpp_type != 'void'">
                    <xsl:value-of select="cpp:ref_var_def($cpp_type, $var_label)" />
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>

        <xsl:sequence select="cpp:join_args($resolved_args)" />
    </xsl:function>

    <xsl:function name="cdit:does_function_return_void" as="xs:boolean">
        <xsl:param name="function" as="element()"/>
        <xsl:value-of select="cdit:get_function_return_parameter_declarations($function) = 'void'" />
    </xsl:function>

    <xsl:function name="cdit:get_function_return_parameter_declarations" as="xs:string*">
        <xsl:param name="node" as="element()"/>

        <xsl:variable name="return_parameter_group" select="graphml:get_child_nodes_of_kind($node, ('ReturnParameterGroup', 'ReturnParameterGroupInstance'))" />
        <xsl:variable name="return_parameters" select="graphml:get_child_nodes($return_parameter_group[1])" />


        <xsl:choose>
            <xsl:when test="count($return_parameters) = 1" >
                <xsl:variable name="cpp_type" select="cpp:get_qualified_type($return_parameters[1])" />
                <xsl:value-of select="cpp:define_variable($cpp_type, '', '', '', 0)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'void'" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:include_aggregate_headers">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="entities" as="element()*" />

        <xsl:for-each select="$entities">
            <xsl:if test="position() = 1">
                <xsl:value-of select="cpp:comment(('Include required', o:wrap_quote($middleware), graphml:get_kind(.), ' header files'), 0)" />
            </xsl:if>
            
            <xsl:variable name="header_file" select="cdit:get_aggregate_h_path($middleware, .)" />
            <xsl:value-of select="cpp:include_local_header($header_file)" />
            <xsl:value-of select="if (position() = last()) then o:nl(1) else ''" />
        </xsl:for-each>
    </xsl:function>

    <xsl:function name="cdit:get_aggregates_middleware_file_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />
        <xsl:variable name="file_path" select="cdit:get_aggregates_path($aggregate)" />
        <xsl:variable name="file_name" select="cdit:get_aggregates_middleware_file_name($aggregate, $middleware)" />
        
        <xsl:value-of select="o:join_paths(($file_path, $file_name))" />
    </xsl:function>

    <xsl:function name="cdit:get_aggregates_generated_middleware_header_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="file_path" select="cdit:get_aggregate_path($middleware, $aggregate)" />
        <xsl:variable name="file_name" select="cdit:get_middleware_generated_header_name($aggregate, $middleware)" />
        
        <xsl:value-of select="o:join_paths(($file_path, $file_name))" />
    </xsl:function>


    

    <xsl:function name="cdit:include_middleware_aggregate_headers">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="entities" as="element()*" />

        <xsl:for-each select="$entities">
            <xsl:if test="position() = 1">
                <xsl:value-of select="cpp:comment(('Include required', o:wrap_quote($middleware), graphml:get_kind(.), ' header files'), 0)" />
            </xsl:if>
            
            <xsl:variable name="header_file" select="cdit:get_aggregates_generated_middleware_header_path($middleware, .)" />
            <xsl:value-of select="cpp:include_local_header($header_file)" />
            <xsl:value-of select="if (position() = last()) then o:nl(1) else ''" />
        </xsl:for-each>
    </xsl:function>

    <xsl:function name="cdit:include_enum_headers">
        <xsl:param name="enums" as="element()*" />
        <xsl:value-of select="cdit:include_aggregate_headers('Base', $enums)" />
    </xsl:function>


    <xsl:function name="cdit:get_qualified_server_interface_request_type">
        <xsl:param name="server_interface" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="server_requests" select="cdit:get_server_interface_request_aggregates($server_interface)" />
        
        <xsl:choose>
            <xsl:when test="count($server_requests) = 1">
                <xsl:value-of select="cpp:get_aggregate_qualified_type($server_requests[1], $middleware)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'void'" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_requester_port_return_type">
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="reply_type" select="cdit:get_qualified_server_interface_reply_type($server_interface, 'base')" />
        <xsl:choose>
            <xsl:when test="$reply_type = 'void'">
                <xsl:value-of select="'bool'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:define_pair('bool', $reply_type)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_base_server_interface_type">
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="reply_type" select="cdit:get_qualified_server_interface_reply_type($server_interface, 'base')" />
        <xsl:variable name="request_type" select="cdit:get_qualified_server_interface_request_type($server_interface, 'base')" />

        <xsl:value-of select="cpp:join_args(($reply_type, $request_type))" />
    </xsl:function>


    <xsl:function name="cdit:get_replier_port_return_type">
        <xsl:param name="server_interface" as="element()" />
        <xsl:value-of select="cdit:get_qualified_server_interface_reply_type($server_interface, 'base')" />
    </xsl:function>

    <xsl:function name="cdit:get_replier_port_parameters">
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="request_type" select="cdit:get_qualified_server_interface_request_type($server_interface, 'base')" />

        <xsl:if test="$request_type != 'void'">
            <xsl:value-of select="cpp:ref_var_def($request_type, 'm')" />
        </xsl:if>
    </xsl:function>

    <xsl:function name="cdit:get_requester_port_parameters">
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="request_type" select="cdit:get_qualified_server_interface_request_type($server_interface, 'base')" />
        
        <xsl:variable name="args" as="xs:string*">
            <xsl:if test="$request_type != 'void'">
                <xsl:sequence select="cpp:ref_var_def($request_type, 'm')" />
            </xsl:if>
            <xsl:sequence select="cpp:const_ref_var_def('std::chrono::milliseconds', 'timeout')" />
        </xsl:variable>
        <xsl:value-of select="cpp:join_args($args)" />
    </xsl:function>


    <xsl:function name="cdit:get_qualified_server_interface_reply_type">
        <xsl:param name="server_interface" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="server_replies" select="cdit:get_server_interface_reply_aggregates($server_interface)" />
        
        <xsl:choose>
            <xsl:when test="count($server_replies) = 1">
                <xsl:value-of select="cpp:get_aggregate_qualified_type($server_replies[1], $middleware)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'void'" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    

     <xsl:function name="cdit:get_server_interface_request_aggregates">
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="request_type" select="graphml:get_child_nodes_of_kind($server_interface, 'InputParameterGroup')" />
        <xsl:sequence select="graphml:get_child_nodes_of_kind($request_type, 'AggregateInstance')" />
    </xsl:function>

    <xsl:function name="cdit:get_server_interface_reply_aggregates">
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="request_type" select="graphml:get_child_nodes_of_kind($server_interface, 'ReturnParameterGroup')" />
        <xsl:sequence select="graphml:get_child_nodes_of_kind($request_type, 'AggregateInstance')" />
    </xsl:function>

    <xsl:function name="cdit:get_unique_variable_name">
        <xsl:param name="node" as="element()*"/>
        <xsl:variable name="id" select="graphml:get_id($node)" />
        <xsl:value-of select="lower-case(o:join_list((cdit:get_variable_name($node), $id), '_'))"/>
    </xsl:function>

    <xsl:function name="cdit:middleware_supports_requestreply" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:value-of select="$middleware='zmq' or $middleware='tao' or $middleware='qpid'"/>
    </xsl:function>

    <xsl:function name="cdit:middleware_supports_pubsub" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:value-of select="$middleware='zmq' or $middleware='qpid' or $middleware ='rti' or $middleware='ospl'"/>
    </xsl:function>
</xsl:stylesheet>

