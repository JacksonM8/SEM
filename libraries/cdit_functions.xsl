<!-- Functions for cpp syntax output -->
<xsl:stylesheet version="2.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:o="http://github.com/cdit-ma/re_gen/o"
    xmlns:graphml="http://github.com/cdit-ma/re_gen/graphml"
    xmlns:cdit="http://github.com/cdit-ma/re_gen/cdit"
    xmlns:cpp="http://github.com/cdit-ma/re_gen/cpp"
    xmlns:proto="http://github.com/cdit-ma/re_gen/proto"
    xmlns:idl="http://github.com/cdit-ma/re_gen/idl"
    xmlns:cmake="http://github.com/cdit-ma/re_gen/cmake"
    xmlns:gml="http://graphml.graphdrawing.org/xmlns"
    >

    <!--
        Get the version number
    -->
    <xsl:function name="cdit:get_re_gen_version" as="xs:string">
        <xsl:value-of select="'re_gen-v3.1.3'" />
    </xsl:function>

    <!--
        Print re-gen info
    -->
    <xsl:function name="cpp:print_regen_version">
        <xsl:param name="transform" as="xs:string" />
        <xsl:param name="function_name" as="xs:string" />
        <xsl:param name="tab" as="xs:integer" />
        
        <xsl:value-of select="cpp:comment(('Generated by:', $transform, o:wrap_bracket(cdit:get_re_gen_version()), o:nl(1), 'Function:', concat($function_name, o:wrap_bracket(''))), $tab)" />
        <xsl:value-of select="o:nl(1)" />
    </xsl:function>

    <!--
        Print re-gen info
    -->
    <xsl:function name="cmake:print_regen_version">
        <xsl:param name="transform" as="xs:string" />
        <xsl:param name="function_name" as="xs:string" />
        <xsl:param name="tab" as="xs:integer" />
        
        <xsl:value-of select="cmake:comment(('Generated by:', $transform, o:wrap_bracket(cdit:get_re_gen_version()), o:nl(1), 'Function:', concat($function_name, o:wrap_bracket(''))), $tab)" />
        <xsl:value-of select="o:nl(1)" />
    </xsl:function>

    


    <!--
        Gets the path to the aggregate folder
    -->
    <xsl:function name="cdit:get_datatype_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="file" as="xs:string" />

        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        <xsl:variable name="aggregate_label" select="graphml:get_label($aggregate)" />

         <xsl:value-of select="lower-case(o:join_paths(($middleware, $aggregate_namespace, $aggregate_label, $file)))" />
    </xsl:function>
    
    <!--
        Gets the name of the middleware_generated_header_name
    -->
    <xsl:function name="cdit:get_middleware_generated_header_name" as="xs:string">
        <xsl:param name="aggregate" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="middleware_extension">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti'">
                    <xsl:value-of select="'.hpp'" />
                </xsl:when>
                <xsl:when test="$middleware = 'ospl'">
                    <xsl:value-of select="'_DCPS.hpp'" />
                </xsl:when>
                <xsl:when test="$middleware = 'proto'">
                    <xsl:value-of select="'.pb.h'" />
                </xsl:when>
                <xsl:when test="$middleware = 'tao'">
                    <xsl:value-of select="'S.h'" />
                </xsl:when>
                <xsl:when test="$middleware = 'base'">
                    <xsl:value-of select="'.h'" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="o:warning(concat('Middleware ', $middleware, ' not implemented'))" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="file_name" select="cdit:get_aggregate_file_prefix($aggregate, $middleware)" />

        <xsl:value-of select="concat($file_name, $middleware_extension)" />
    </xsl:function>

    <xsl:function name="cdit:middleware_requires_idl_file" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:variable name="middleware_lc" select="lower-case($middleware)" />
        <xsl:value-of select="$middleware_lc = 'rti' or $middleware_lc = 'ospl' or $middleware_lc = 'tao'" />
    </xsl:function>

    <xsl:function name="cdit:middleware_requires_proto_file" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:variable name="middleware_lc" select="lower-case($middleware)" />
        <xsl:value-of select="$middleware_lc = 'proto'" />
    </xsl:function>



    <!--
        Gets the name of the middleware_generated_header_name
    -->
    <xsl:function name="cdit:middleware_uses_ref_setter" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string" />
        
        <xsl:value-of select="$middleware = 'rti' or $middleware = 'ospl' or cdit:middleware_uses_protobuf($middleware)" />
    </xsl:function>

    <xsl:function name="cdit:get_middleware_variable_syntax" as="xs:string">
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="label" select="graphml:get_label($node)" />

        <xsl:choose>
    
            <xsl:when test="$middleware = 'ospl' or $middleware = 'rti'">
                <!-- DDS uses exact case -->
                <xsl:value-of select="lower-case($label)" />
            </xsl:when>
            <xsl:when test="$middleware = 'tao'">
                <!-- DDS uses exact case -->
                <xsl:value-of select="lower-case($label)" />
            </xsl:when>
            <xsl:when test="$middleware = 'base'">
                <!-- Base uses exact case -->
                <xsl:value-of select="$label" />
            </xsl:when>
            <xsl:when test="cdit:middleware_uses_protobuf($middleware)">
                <!-- Protobuf uses lowercase -->
                <xsl:value-of select="lower-case($label)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:comment_inline(concat('Middleware ', $middleware, ' not implemented'))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:middleware_uses_protobuf" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:value-of select="$middleware='qpid' or $middleware='zmq' or $middleware='proto'" />
    </xsl:function>

    <xsl:function name="cdit:middleware_uses_dds" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:value-of select="$middleware='rti' or $middleware='ospl'" />
    </xsl:function>

    <xsl:function name="cdit:get_middleware_namespace" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:value-of select="lower-case($middleware)" />
    </xsl:function>

    <xsl:function name="cdit:invoke_middleware_get_function" as="xs:string">
        <xsl:param name="obj" as="xs:string"/>
        <xsl:param name="operator" as="xs:string"/>
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="parent_node" select="graphml:get_parent_node($node)" />
        <xsl:variable name="kind" select="graphml:get_kind($node)" />
        <xsl:variable name="node_type" select="graphml:get_type($node)" />
        <xsl:variable name="is_union" select="graphml:evaluate_data_value_as_boolean($parent_node, 'is_union')" />

        <xsl:variable name="variable_syntax" select="cdit:get_middleware_variable_syntax($node, $middleware)" />
        <xsl:variable name="function_name">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti'">
                    <xsl:choose>
                        <xsl:when test="$kind = 'EnumInstance' or $kind = 'Enum'">
                            <!-- RTI uses a SafeEnum which requires some magic -->
                            <xsl:value-of select="concat($variable_syntax, '().underlying')" />
                        </xsl:when>
                        <xsl:otherwise>
                            <!-- DDS uses exact case -->
                            <xsl:value-of select="$variable_syntax" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
            
                <xsl:when test="$middleware = 'ospl'">
                    <!-- DDS implementations use get/set via accessors -->
                    <xsl:value-of select="$variable_syntax" />
                </xsl:when>
                <xsl:when test="$middleware = 'tao'">
                    <!-- DDS implementations use get/set via accessors -->
                    <xsl:value-of select="$variable_syntax" />
                </xsl:when>
                <xsl:when test="$middleware = 'base'">
                    <!-- Base uses both get/set functions both via accessors and functions -->
                    <xsl:value-of select="concat('get_', $variable_syntax)" />
                </xsl:when>
                <xsl:when test="$middleware = 'proto'">
                    <!-- Protobuf offers a const ref getter -->
                    <xsl:value-of select="lower-case($variable_syntax)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="cpp:comment_inline(concat('Middleware ', $middleware, ' not implemented'))" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="value">
            <xsl:choose>
                <xsl:when test="$middleware = 'tao' and $is_union = false() ">
                    <xsl:value-of select="concat($obj, $operator, $function_name)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="cpp:invoke_function($obj, $operator, $function_name, '', 0)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$middleware = 'tao' and $node_type = 'String'">
                <!-- String wrap corba strings -->
                <xsl:value-of select="concat('std::string(', $value, ')')" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$value" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:middleware_handles_union" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:value-of select="$middleware = 'tao' or $middleware = 'rti' or $middleware = 'ospl' or $middleware = 'base'" />
    </xsl:function>

    <xsl:function name="cdit:invoke_middleware_add_vector_function">
        <xsl:param name="obj" as="xs:string"/>
        <xsl:param name="operator" as="xs:string"/>
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="value" as="xs:string" />
        <xsl:param name="tab" as="xs:integer" />

        <xsl:variable name="node_kind" select="graphml:get_kind($node)" />
        <xsl:variable name="variable_syntax" select="cdit:get_middleware_variable_syntax($node, $middleware)" />

        <xsl:variable name="vector_child" select="graphml:get_vector_child($node)" />
        <xsl:variable name="vector_kind" select="graphml:get_kind($vector_child)" />
        <xsl:variable name="vector_type" select="graphml:get_type($vector_child)" />
        
        <xsl:variable name="set_value">
            <xsl:choose>
                <xsl:when test="$vector_kind = 'AggregateInstance' and $middleware != 'proto'">
                    <xsl:value-of select="cpp:dereference_var($value)" />
                </xsl:when>
                <xsl:when test="$vector_kind = 'Member' and $vector_type = 'String' and $middleware = 'tao'">
                    <xsl:value-of select="concat($value, '.c_str()')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$value" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="vector_ref">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti' or $middleware = 'ospl'">
                    <xsl:value-of select="cpp:invoke_function($obj, cpp:arrow(), $variable_syntax, '', 0)" />
                </xsl:when>
                <xsl:when test="$middleware = 'base'">
                    <xsl:value-of select="cpp:invoke_function($obj, cpp:arrow(), $variable_syntax, '', 0)" />
                </xsl:when>
                <xsl:when test="$middleware = 'tao'">
                    <xsl:value-of select="concat($obj, $operator, $variable_syntax)" />
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="requires_idl" select="cdit:middleware_requires_idl_file($middleware)" />
        <xsl:variable name="is_array" select="graphml:evaluate_data_value_as_boolean($node, 'is_array')" />
        <xsl:choose>

            <xsl:when test="$is_array and $requires_idl">
                <xsl:value-of select="concat(o:t($tab), $vector_ref, o:wrap_square('i'), ' = ', $set_value, cpp:nl())" />
            </xsl:when>
            <xsl:when test="$middleware = 'tao'">
                <xsl:variable name="vector_ref" select="concat($obj, $operator, $variable_syntax)" />
                <xsl:value-of select="concat(o:t($tab), 'if(i == 0)', cpp:scope_start(0))" />
                    <xsl:value-of select="concat(cpp:invoke_function($vector_ref, cpp:dot(), 'length', 'size', $tab + 1), cpp:nl())" />
                <xsl:value-of select="cpp:scope_end($tab)" />
                
                <xsl:value-of select="concat(o:t($tab), $vector_ref, o:wrap_square('i'), ' = ', $set_value, cpp:nl())" />
            </xsl:when>
            <xsl:when test="$requires_idl">
                <xsl:value-of select="concat(cpp:invoke_function($vector_ref, cpp:dot(), 'resize', cpp:join_args(('i', $set_value)), $tab), cpp:nl())" />
            </xsl:when>
            <xsl:when test="$middleware = 'rti' or $middleware = 'ospl'">
                <xsl:value-of select="concat(cpp:invoke_function($vector_ref, cpp:dot(), 'resize', $set_value, $tab), cpp:nl())" />
            </xsl:when>
            <xsl:when test="$middleware = 'proto' and $vector_kind = 'AggregateInstance'">
                <xsl:variable name="added_element" select="cpp:invoke_function($obj, cpp:arrow(), concat('add_', $variable_syntax), '', 0)" />
                <!-- Vectors with Objects in it can use a mutable_swap function -->
                <xsl:value-of select="concat(cpp:invoke_function($added_element, cpp:arrow(), 'Swap', $set_value, $tab), cpp:nl())" />
            </xsl:when>
            <xsl:when test="$middleware = 'proto'">
                <xsl:value-of select="concat(cpp:invoke_function($obj, cpp:arrow(), concat('add_', $variable_syntax), $set_value, $tab), cpp:nl())" />
            </xsl:when>
            <xsl:when test="$middleware = 'base'">
                <xsl:value-of select="concat(cpp:invoke_function($vector_ref, cpp:dot(), 'emplace_back', $set_value, $tab), cpp:nl())" />
            </xsl:when>
            <xsl:otherwise>
            </xsl:otherwise>
        </xsl:choose>

        
    </xsl:function>
    

    <xsl:function name="cdit:invoke_middleware_set_function" as="xs:string">
        <xsl:param name="obj" as="xs:string"/>
        <xsl:param name="operator" as="xs:string"/>
        <xsl:param name="node" as="element()" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="value" as="xs:string" />

        <xsl:variable name="node_kind" select="graphml:get_kind($node)" />
        <xsl:variable name="node_type" select="graphml:get_type($node)" />
        <xsl:variable name="parent_node" select="graphml:get_parent_node($node)" />
        <xsl:variable name="is_union" select="graphml:evaluate_data_value_as_boolean($parent_node, 'is_union')" />

        <xsl:variable name="variable_syntax" select="cdit:get_middleware_variable_syntax($node, $middleware)" />

        <xsl:variable name="resolved_value">
            <xsl:choose>
                <xsl:when test="$middleware = 'tao' and $node_type = 'String'">
                    <xsl:value-of select="concat($value, '.c_str()')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$value" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="function_name">
            <xsl:choose>
                <xsl:when test="$middleware = 'rti' or $middleware = 'ospl' or $middleware = 'tao'">
                    <xsl:value-of select="$variable_syntax" />
                </xsl:when>
                 <xsl:when test="$middleware = 'base'">
                    <!-- Base uses both get/set functions both via accessors and functions -->
                    <xsl:value-of select="concat('set_', $variable_syntax)" />
                </xsl:when>
                <xsl:when test="$middleware = 'proto'">
                    <xsl:choose>
                        <xsl:when test="$node_kind = 'AggregateInstance'">
                            <!-- Protobuf uses swap for Instances -->
                            <xsl:value-of select="concat(cpp:invoke_function('', '', concat('mutable_', $variable_syntax), '', 0), cpp:arrow(), 'Swap')" />
                        </xsl:when>
                        <xsl:when test="$node_kind = 'Member' or $node_kind = 'EnumInstance'">
                            <!-- Protobuf implementations use set via functions -->
                            <xsl:value-of select="concat('set_', $variable_syntax)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="cpp:comment_inline(concat('Kind ', $node_kind, ' not implemented'))" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="cpp:comment_inline(concat('Middleware ', $middleware, ' not implemented'))" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$middleware = 'tao' and $is_union = false()">
                <xsl:value-of select="concat($obj, $operator, $function_name, ' = ', $resolved_value)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:invoke_function($obj, $operator, $function_name, $resolved_value, 0)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cpp:get_qualified_type" as="xs:string">
        <xsl:param name="node" as="element()?" />
        <xsl:variable name="kind" select="graphml:get_kind($node)" />
        
        <xsl:choose>    
            <xsl:when test="$kind = 'Member' or $kind = 'Attribute'">
                <xsl:value-of select="cpp:get_member_type($node)" />
            </xsl:when>
            <xsl:when test="$kind = 'VoidType'">
                <xsl:value-of select="'void'" />
            </xsl:when>
            <xsl:when test="$kind = 'Variable'">
                <xsl:variable name="child" select="graphml:get_child_node($node, 1)" />
                <xsl:choose>
                    <xsl:when test="$child">
                        <xsl:value-of select="cpp:get_qualified_type($child)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="cpp:get_member_type($node)" />
                    </xsl:otherwise>
                </xsl:choose> 
            </xsl:when>
            <xsl:when test="$kind = 'EnumInstance'">
                <xsl:value-of select="cdit:get_qualified_enum_type($node, 'base')" />
            </xsl:when>
            <xsl:when test="$kind = 'AggregateInstance' or $kind = 'Aggregate'">
                <xsl:value-of select="cdit:get_aggregate_qualified_type($node, 'base')" />
            </xsl:when>
            <xsl:when test="$kind = 'Vector'">
                <xsl:value-of select="cpp:get_vector_qualified_type($node)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="o:warning(('cpp:get_qualified_type()', 'Node Kind:', o:wrap_quote($kind), 'Not Implemented'))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cpp:get_member_type" as="xs:string">
        <xsl:param name="member" as="element()" />

        <xsl:variable name="type" select="graphml:get_type($member)" />
        <xsl:value-of select="cpp:get_primitive_type($type)" />
    </xsl:function>

    <xsl:function name="cdit:get_enum_type" as="xs:string">
        <xsl:param name="enum" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="enum_definition" select="graphml:get_definition($enum)" />
        <!--<xsl:variable name="enum_namespace" select="graphml:get_namespace($enum_definition)" />-->
        <xsl:variable name="label" select="o:title_case(graphml:get_label($enum_definition))" />

        <xsl:choose>
            <xsl:when test="cdit:middleware_uses_protobuf($middleware)">
                <xsl:value-of select="$label" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$label" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_enum_member_type" as="xs:string">
        <xsl:param name="enum_member" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="enum_member_label" select="graphml:get_label($enum_member)" />

        <xsl:variable name="var_name">
            <xsl:choose>
                <xsl:when test="cdit:middleware_uses_protobuf($middleware)">
                    <xsl:variable name="enum" select="graphml:get_parent_node($enum_member)" />
                    <xsl:variable name="enum_type" select="cdit:get_enum_type($enum, $middleware)" />
                    <!-- Note that enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children of it. -->
                    <xsl:value-of select="o:join_list(($enum_type, $enum_member_label), '_')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$enum_member_label" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="upper-case($var_name)" />
    </xsl:function>




    <xsl:function name="cdit:get_aggregates_middleware_file_name" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="aggregate_label" select="cdit:get_aggregate_file_prefix($aggregate, $middleware)" />

      
        <xsl:variable name="middleware_extension" select="cdit:get_middleware_extension($middleware)" />


        <xsl:value-of select="o:join_list(($aggregate_label, $middleware_extension), '.')" />
    </xsl:function>



    <xsl:function name="cdit:get_middleware_extension" as="xs:string">
        <xsl:param name="middleware" as="xs:string"/>

        <xsl:variable name="middleware_lc" select="lower-case($middleware)" />
        
        <xsl:choose>
            <xsl:when test="$middleware_lc = 'rti' or $middleware_lc = 'ospl' or $middleware_lc = 'tao'">
                <xsl:value-of select="'idl'" />
            </xsl:when>
            <xsl:when test="$middleware_lc = 'proto'">
                <xsl:value-of select="'proto'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('UNKNOWN_MIDDLEWARE_', $middleware)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>



    

    <xsl:function name="cpp:get_vector_qualified_type" as="xs:string">
        <xsl:param name="vector" as="element()" />

        <xsl:variable name="vector_child" select="graphml:get_vector_child($vector)" />
        <xsl:variable name="child_type" select="cpp:get_qualified_type($vector_child)" />
        <xsl:if test="$child_type != ''">
            <xsl:value-of select="concat('std::vector', o:wrap_angle($child_type))" />
        </xsl:if>
    </xsl:function>

    <xsl:function name="cdit:variablize_value" as="xs:string">
        <xsl:param name="variable" as="xs:string" />
        <xsl:value-of select="if($variable != '') then concat($variable, '_') else ''" />
    </xsl:function>

    <xsl:function name="cdit:get_variable_label" as="xs:string">
        <xsl:param name="label" as="xs:string" />
        <xsl:param name="node" as="element()?" />

        <xsl:variable name="kind" select="graphml:get_kind($node)" />
        <xsl:variable name="parent_node" select="graphml:get_parent_node($node)" />
        <xsl:variable name="parent_kind" select="graphml:get_kind($parent_node)" />

        <xsl:variable name="ancestor_kinds" select="($kind, graphml:get_data_values(graphml:get_ancestor_nodes($node), 'kind'))" />

        <xsl:variable name="prefix">
            <xsl:choose>
                <xsl:when test="$parent_kind = 'Class' or
                                $parent_kind = 'ComponentImpl'">
                    <xsl:value-of select="'g'" />
                </xsl:when>
                <xsl:when test="'InputParameterGroup' = $ancestor_kinds or
                                'InputParameterGroupInstance' = $ancestor_kinds">
                    <xsl:value-of select="'p'" />
                </xsl:when>
                <xsl:when test="$kind = 'AggregateInstance' and
                        ($parent_kind = 'SubscriberPortImpl'
                        )
                        ">
                    <xsl:value-of select="'p'" />
                </xsl:when>
                <xsl:when test="$node">
                    <xsl:value-of select="'m'" />
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="suffix">
            <xsl:choose>
                <xsl:when test="'InputParameterGroupInstance' = $ancestor_kinds or
                                'PublisherPortImpl' = $ancestor_kinds or
                                'RequesterPortImpl' = $ancestor_kinds or
                                'ReturnParameterGroupInstance' = $ancestor_kinds or
                                'Setter' = $kind
                                ">
                    <xsl:value-of select="graphml:get_id($node)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="''" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="o:join_list(($prefix, $label, $suffix), '_')" />
    </xsl:function>


    <xsl:function name="cpp:get_aggregate_type_name" as="xs:string">
        <xsl:param name="aggregate_inst" as="element()" />
        <xsl:variable name="aggregate" select="graphml:get_definition($aggregate_inst)" />
        <xsl:variable name="label" select="o:title_case(graphml:get_label($aggregate))" />
        <xsl:value-of select="$label" />
    </xsl:function>

    <xsl:function name="cpp:get_component_type_name" as="xs:string">
        <xsl:param name="component" as="element()" />

        <xsl:value-of select="cpp:get_aggregate_type_name($component)" />
    </xsl:function>

    <xsl:function name="cpp:get_server_qualified_type" as="xs:string">
        <xsl:param name="server_inst" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="server_def" select="graphml:get_definition($server_inst)" />

        <xsl:variable name="namespace" select="graphml:get_namespace($server_inst)" />
        
        <xsl:variable name="interface_name" select="graphml:get_data_value($server_def, 'interface_name')" />

        <xsl:variable name="combined_namespace" select="cpp:combine_namespaces(($namespace, $interface_name))" />
        <xsl:value-of select="concat('::', 'POA_', $combined_namespace)" />
    </xsl:function>

    <xsl:function name="cpp:get_client_qualified_type" as="xs:string">
        <xsl:param name="server_inst" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="server_def" select="graphml:get_definition($server_inst)" />

        <xsl:variable name="namespace" select="graphml:get_namespace($server_inst)" />
        
        <xsl:variable name="interface_name" select="graphml:get_data_value($server_def, 'interface_name')" />

        <xsl:variable name="combined_namespace" select="cpp:combine_namespaces(($namespace, $interface_name))" />
        <xsl:value-of select="concat('::', $combined_namespace)" />
    </xsl:function>

        
    <!-- Converts from the Aggregate Types into primitive CPP types -->
    <xsl:function name="cpp:get_primitive_type" as="xs:string">
        <xsl:param name="type" as="xs:string"  />

        <xsl:choose>
            <xsl:when test="$type = 'String'">
                <xsl:value-of select="'std::string'" />
            </xsl:when>
            <xsl:when test="$type = 'Boolean'">
                <xsl:value-of select="'bool'" />
            </xsl:when>
            <xsl:when test="$type = 'Character'">
                <xsl:value-of select="'char'" />
            </xsl:when>
            <xsl:when test="$type = 'FloatNumber' or $type = 'Float'">
                <xsl:value-of select="'float'" />
            </xsl:when>
            <xsl:when test="$type = 'DoubleNumber' or $type = 'LongDoubleNumber' or $type = 'Double'">
                <xsl:value-of select="'double'" />
            </xsl:when>
            <xsl:when test="$type = 'LongInteger' or $type = 'Integer'">
                <xsl:value-of select="'int'" />
            </xsl:when>
            <xsl:when test="$type = 'UnsignedLongInteger'">
                <xsl:value-of select="'unsigned int'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>Warning: Unknown Type <xsl:value-of select="o:wrap_quote($type)" /></xsl:message>
                <xsl:value-of select="''" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:is_number_type" as="xs:boolean">
        <xsl:param name="type" as="xs:string"  />

        <xsl:value-of select="  $type = 'Boolean' or
                                $type = 'Character' or
                                $type = 'Float' or
                                $type = 'Double' or
                                $type = 'Integer'" />
    </xsl:function>

    <xsl:function name="cdit:compare_nodes_types" as="xs:boolean">
        <xsl:param name="source" as="element()"/>
        <xsl:param name="target" as="element()"/>

        <xsl:variable name="type_1" select="graphml:get_type($source)" />
        <xsl:variable name="type_2" select="graphml:get_type($target)" />

        <xsl:choose>
            <xsl:when test="$type_1 = $type_2">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:when test="cdit:is_number_type($type_1) and cdit:is_number_type($type_2)">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:when test="graphml:get_kind($target) = 'VariadicParameter'">
                <xsl:value-of select="true()" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="false()" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cpp:get_corba_primitive_type" as="xs:string">
        <xsl:param name="type" as="xs:string"  />
        <xsl:choose>
            <xsl:when test="$type = 'short'">
                <xsl:value-of select="'int16_t'" />
            </xsl:when>
            <xsl:when test="$type = 'unsigned short'">
                <xsl:value-of select="'uint16_t'" />
            </xsl:when>
            <xsl:when test="$type = 'long'">
                <xsl:value-of select="'int32_t'" />
            </xsl:when>
            <xsl:when test="$type = 'long long'">
                <xsl:value-of select="'int64_t'" />
            </xsl:when>
            <xsl:when test="$type = 'unsigned long'">
                <xsl:value-of select="'uint32_t'" />
            </xsl:when>
            <xsl:when test="$type = 'unsigned long long'">
                <xsl:value-of select="'uint64_t'" />
            </xsl:when>
            <xsl:when test="$type = 'float' or $type = 'double' or $type = 'char'">
                <xsl:value-of select="$type" />
            </xsl:when>
            <xsl:when test="$type = 'string'">
                <xsl:value-of select="'std::string'" />
            </xsl:when>
            <xsl:when test="$type = 'boolean'">
                <xsl:value-of select="'bool'" />
            </xsl:when>
            <xsl:when test="$type = 'octet'">
                <xsl:value-of select="'uint8_t'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="''" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    

    <xsl:function name="proto:get_aggregate_qualified_type" as="xs:string">
        <xsl:param name="aggregate" as="element()"/>

        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        <xsl:variable name="aggregate_label" select="o:title_case(graphml:get_label($aggregate))" />

        <xsl:choose>
            <xsl:when test="$aggregate_namespace = ''">
                <xsl:value-of select="$aggregate_label" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="o:join_list(($aggregate_namespace, $aggregate_label), '.')" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="idl:get_aggregate_qualified_type" as="xs:string">
        <xsl:param name="aggregate" as="element()"/>

        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        <xsl:variable name="aggregate_label" select="o:title_case(graphml:get_label($aggregate))" />


        <xsl:choose>
            <xsl:when test="$aggregate_namespace = ''">
                <xsl:value-of select="concat('::', $aggregate_label)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:combine_namespaces(($aggregate_namespace, $aggregate_label))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_all_middlewares" as="xs:string*">
        <xsl:sequence select="'zmq'" />
        <xsl:sequence select="'rti'" />
        <xsl:sequence select="'ospl'" />
        <xsl:sequence select="'qpid'" />
        <xsl:sequence select="'tao'" />
    </xsl:function>



    

    
    

    <!--
        Gets the Ports Definitions of the aggregate provided
    -->
    <xsl:function name="cdit:get_eventports_for_aggregate" as="element(gml:node)*">
        <xsl:param name="aggregate" as="element(gml:node)?" />
        
        <xsl:variable name="model" select="graphml:get_ancestor_nodes_of_kind($aggregate, 'Model')" />
        
        <xsl:for-each select="graphml:get_descendant_nodes_of_kind($model, ('PublisherPort', 'SubscriberPort'))">
            <xsl:variable name="aggregate_instance" select="graphml:get_child_node(., 1)" />
            <xsl:variable name="aggregate_definition" select="graphml:get_definition($aggregate_instance)" />

            <xsl:if test="$aggregate_definition = $aggregate">
                <xsl:sequence select="."/>
            </xsl:if>
        </xsl:for-each>
    </xsl:function>

    



    

    <xsl:function name="cdit:parse_components" as="xs:string*">
        <xsl:param name="components" as="xs:string*"/>

        <xsl:variable name="token_middlewares" select="tokenize(normalize-space(lower-case($components)), ',')" />
        <xsl:sequence select="distinct-values($token_middlewares)"/>
    </xsl:function>

    <xsl:function name="cdit:get_components_path" as="xs:string">
        <xsl:param name="component" as="element()" />
        <xsl:value-of select="cdit:get_namespace_type_path($component)" />
    </xsl:function>

    

    <xsl:function name="cdit:get_server_interface_path" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="aggregate_label" select="graphml:get_label($aggregate)" />
        <xsl:variable name="aggregate_namespace" select="graphml:get_namespace($aggregate)" />
        
        <xsl:value-of select="lower-case(o:join_paths(($aggregate_namespace, $aggregate_label)))" />
    </xsl:function>

    <xsl:function name="cdit:get_base_aggregates_cpp_path" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="path" select="cdit:get_namespace_type_path($aggregate)" />
        <xsl:variable name="file" select="cdit:get_base_aggregate_cpp_name($aggregate)" />
        <xsl:value-of select="o:join_paths(($path, $file))" />
    </xsl:function>

    <xsl:function name="cdit:get_base_aggregate_h_name" as="xs:string">
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="file_name" select="cdit:get_aggregate_file_prefix($aggregate, 'base')" />
        <xsl:value-of select="concat($file_name,'.h')" />
    </xsl:function>

    <xsl:function name="cdit:get_base_aggregate_cpp_name" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        
        <xsl:variable name="aggregate_label" select="lower-case(graphml:get_label($aggregate))" />
        <xsl:value-of select="concat($aggregate_label,'.cpp')" />
    </xsl:function>



    <xsl:function name="cdit:get_pubsub_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="path" select="cdit:get_namespace_type_path($aggregate)" />
        <xsl:value-of select="lower-case(o:join_paths(('ports', 'pubsub', $middleware, $path)))" />
    </xsl:function>

    <xsl:function name="cdit:get_reqrep_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="path" select="cdit:get_namespace_type_path($server_interface)" />
        <xsl:value-of select="lower-case(o:join_paths(('ports', 'requestreply', $middleware, $path)))" />
    </xsl:function>


    <xsl:function name="cdit:get_component_path" as="xs:string">
        <xsl:param name="component" as="element()" />

        <xsl:variable name="path" select="cdit:get_components_path($component)" />
        <xsl:value-of select="lower-case(o:join_paths(('components', $path)))" />
    </xsl:function>

    <xsl:function name="cdit:get_class_path" as="xs:string">
        <xsl:param name="class" as="element()" />

        <xsl:variable name="path" select="cdit:get_components_path($class)" />
        <xsl:value-of select="lower-case(o:join_paths(('classes', $path)))" />
    </xsl:function>

    <xsl:function name="cdit:get_aggregate_h_path" as="xs:string">
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="path" select="cdit:get_aggregate_path_for_middleware($aggregate, $middleware)" />
        <xsl:variable name="file" select="cdit:get_base_aggregate_h_name($aggregate)" />
        <xsl:value-of select="o:join_paths(($path, $file))" />
    </xsl:function>

    <xsl:function name="cdit:get_base_enum_h_path" as="xs:string">
        <xsl:param name="enum" as="element()" />

        <xsl:variable name="path" select="cdit:get_aggregate_path_for_middleware($enum, 'base')" />
        <xsl:variable name="file" select="cdit:get_base_aggregate_h_name($enum)" />
        <xsl:value-of select="o:join_paths(('enums', $path, $file))" />
    </xsl:function>

    <!-- Get all required aggregates -->
    <xsl:function name="cdit:get_required_aggregates" as="element()*">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="ignore_nested" as="xs:boolean" />
        
        <!-- Get All Aggregates Used in this entity -->
        <xsl:variable name="aggregate_definitions" select="graphml:get_definitions(graphml:get_descendant_nodes_of_kind($aggregate, 'AggregateInstance'))" />

        <xsl:variable name="ignored_definitions" as="element()*">
            <xsl:if test="$ignore_nested">
                <xsl:sequence select="graphml:get_definitions($aggregate_definitions/graphml:get_descendant_nodes_of_kind(., 'AggregateInstance'))" />
            </xsl:if>
        </xsl:variable>
        
        <!-- Return the Aggregates Required, which are not nested -->
         <xsl:for-each select="$aggregate_definitions except $ignored_definitions">
            <xsl:if test="graphml:get_kind(.) = 'Aggregate'">
                <xsl:sequence select="." />
            </xsl:if>
        </xsl:for-each>
    </xsl:function>

    <!-- Get all required aggregates -->
    <xsl:function name="cdit:get_required_enums" as="element()*">
        <xsl:param name="entity" as="element()" />
        
        <!-- Get All Aggregates Used in this entity -->
        <xsl:variable name="enum_definitions" select="graphml:get_definitions(graphml:get_descendant_nodes_of_kind($entity, 'EnumInstance'))" />
        
        <!-- Return the Aggregates Required, which are not nested -->
        <xsl:sequence select="$enum_definitions" />
    </xsl:function>

    <xsl:function name="cdit:get_function_name" as="xs:string">
        <xsl:param name="port" as="element()"/>
        <xsl:variable name="port_def" select="graphml:get_definition($port)" />
        <xsl:variable name="def_kind" select="graphml:get_kind($port_def)" />
        <xsl:variable name="def_label" select="graphml:get_label($port_def)" />
        
        <xsl:variable name="port_label" select="graphml:get_label($port)" />
        <xsl:variable name="port_kind" select="graphml:get_kind($port)" />

        <xsl:variable name="prefix">
            <xsl:choose>
                <xsl:when test="$def_kind = 'SubscriberPort'">
                    <xsl:value-of select="'Sub'" />
                </xsl:when>
                <xsl:when test="$def_kind = 'PublisherPort'">
                    <xsl:value-of select="'Pub'" />
                </xsl:when>
                <xsl:when test="$port_kind = 'ReplierPort' or $port_kind = 'ReplierPortImpl'">
                    <xsl:value-of select="'Rep'" />
                </xsl:when>
                <xsl:when test="$port_kind = 'RequesterPort' or $port_kind = 'RequesterPortImpl'">
                    <xsl:value-of select="'Req'" />
                </xsl:when>
                <xsl:when test="$def_kind = 'PeriodicPort'">
                    <xsl:value-of select="'Periodic'" />
                </xsl:when>
                <xsl:when test="$def_kind = 'Function'">
                    <xsl:value-of select="'Fn'" />
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="label">
            <xsl:choose>
                <xsl:when test="$def_kind = 'ServerInterface' ">
                    <xsl:value-of select="$port_label" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$def_label" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="o:join_list(($prefix, $label), '_')" />
    </xsl:function>
    

    <xsl:function name="cdit:comment_graphml_node">
        <xsl:param name="element" as="element()" />
        <xsl:param name="tab" as="xs:integer" />

        <xsl:if test="$debug_mode">
            <xsl:value-of select="cpp:comment((o:wrap_square(graphml:get_kind($element)), graphml:get_label($element), o:wrap_angle(graphml:get_id($element))), $tab)" />
        </xsl:if>
    </xsl:function>


    <xsl:function name="cdit:get_default_primitive_value">
        <xsl:param name="type" as="xs:string" />
        <xsl:choose>
            <xsl:when test="$type = 'String'">
                <xsl:value-of select="o:wrap_dblquote('')"/>
            </xsl:when>
            <xsl:when test="$type = 'Boolean'">
                <xsl:value-of select="'false'"/>
            </xsl:when>
            <xsl:when test="$type = 'Double' or $type = 'Float'">
                <xsl:value-of select="'0.0'"/>
            </xsl:when>
            <xsl:when test="$type = 'Integer' or $type = 'Character'">
                <xsl:value-of select="'0'"/>
            </xsl:when>
        </xsl:choose>
    </xsl:function>

    

    <xsl:function name="cdit:declare_custom_function">
        <xsl:param name="function" as="element()" />
        <xsl:param name="tab" as="xs:integer" />

        <xsl:variable name="name" select="cdit:get_function_name($function)" />
        <xsl:variable name="return_parameter" select="cdit:get_function_return_type($function)" />
        <xsl:variable name="input_parameters" select="cdit:get_function_parameters($function)" />
        
        <xsl:value-of select="cdit:comment_graphml_node($function, $tab)" />
        <xsl:value-of select="cpp:declare_function($return_parameter, $name, $input_parameters, ';', $tab)" />
    </xsl:function>

    
    
    
    <xsl:function name="cdit:declare_variable">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="tab" as="xs:integer" />
         
        <xsl:variable name="label" select="graphml:get_label($aggregate)" />
        <xsl:variable name="kind" select="graphml:get_kind($aggregate)" />
        <xsl:variable name="cpp_type" select="cpp:get_qualified_type($aggregate)" />
        <xsl:variable name="var_label" select="cdit:get_variable_name($aggregate)" />
        <xsl:variable name="set_value" select="graphml:get_data_value($aggregate, 'value')" />

        <xsl:variable name="value">
            <xsl:choose>
                <xsl:when test="$set_value != ''">
                    <xsl:value-of select="$set_value" />
                </xsl:when>
                <xsl:when test="$kind = 'EnumInstance'">
                    <xsl:variable name="enum_def" select="graphml:get_definition($aggregate)" />
                    <xsl:variable name="enum_member" select="graphml:get_child_node($enum_def, 1)" />
                    <xsl:if test="$enum_member">
                        <xsl:value-of select="cdit:get_qualified_enum_member_type($enum_member)" />
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$kind = 'MemberInstance' or $kind = 'Member' or $kind = 'Variable'">
                    <xsl:variable name="member_def" select="graphml:get_definition($aggregate)" />
                    <xsl:variable name="member_type" select="graphml:get_type($member_def)" />
                    <xsl:variable name="child" select="graphml:get_child_node($member_def, 1)" />
                    <xsl:if test="not($child)">
                        <xsl:value-of select="cdit:get_default_primitive_value($member_type)" />
                    </xsl:if>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="cpp:define_variable($cpp_type, $var_label, $value, cpp:nl(), $tab)" />

    </xsl:function>

    <xsl:function name="cdit:declare_datatype_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="tab" as="xs:integer" />
        
        <xsl:variable name="label" select="graphml:get_label($aggregate)" />
        <xsl:variable name="kind" select="graphml:get_kind($aggregate)" />
        <xsl:variable name="cpp_type" select="cpp:get_qualified_type($aggregate)" />
        <xsl:variable name="var_label" select="cdit:get_variable_name($aggregate)" />
        <xsl:variable name="set_value" select="graphml:get_data_value($aggregate, 'value')" />
        
        <xsl:choose>
            <xsl:when test="$cpp_type != ''">
                <!-- Public Declarations -->
                <xsl:value-of select="cpp:public($tab)" />
                <xsl:value-of select="cdit:comment_graphml_node($aggregate, $tab + 1)" />
                <xsl:value-of select="cpp:declare_function('void', concat('set_', $label), cpp:const_ref_var_def($cpp_type, 'value'), ';', $tab + 1)" />
                <xsl:value-of select="cpp:declare_function(cpp:const_ref_var_def($cpp_type, ''), concat('get_', $label), '', ' const;', $tab + 1)" />
                <xsl:value-of select="cpp:declare_function(cpp:ref_var_def($cpp_type, ''), $label, '', ';', $tab + 1)" />
                <!-- Private Declarations -->
                <xsl:value-of select="cpp:private($tab)" />
                <xsl:choose>
                    <xsl:when test="$kind != 'Attribute'">
                        <xsl:value-of select="cdit:declare_variable($aggregate, $tab + 1)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="cpp:declare_variable(cpp:shared_ptr('Attribute'), $var_label, cpp:nl(), $tab + 1)" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cdit:comment_graphml_node($aggregate, $tab)" />
                <xsl:value-of select="cpp:comment('Cannot find valid CPP type for this element', $tab)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_union_descrimantor_type">
        <xsl:param name="aggregate" as="element()" />
        <xsl:variable name="label" select="graphml:get_label($aggregate)" />
        <xsl:value-of select="o:join_list((o:title_case($label), 'Descriminator'), '_')" />
    </xsl:function>

    <xsl:function name="cdit:get_qualified_union_descrimantor_type">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:choose>
            <xsl:when test="$middleware = 'base'">
                <xsl:variable name="aggregate_type" select="cdit:get_aggregate_qualified_type($aggregate, $middleware)" />
                <xsl:variable name="descriminator_enum_type" select="cdit:get_union_descrimantor_type($aggregate)" />
                <xsl:value-of select="cpp:combine_namespaces(($aggregate_type, $descriminator_enum_type))" />
            </xsl:when>
            <xsl:when test="$middleware = 'tao'">
                <xsl:value-of select="cpp:combine_namespaces(graphml:get_namespace($aggregate))" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="namespace" select="graphml:get_namespace($aggregate)" />
                <xsl:variable name="aggregate_label" select="cpp:get_aggregate_type_name($aggregate)" />
                <xsl:variable name="descriminator_enum_type" select="concat(cdit:get_union_descrimantor_type($aggregate), '_def')" />
                <xsl:variable name="enum_type" select="o:join_list(($namespace, $descriminator_enum_type), '_')" />
                <xsl:value-of select="cpp:combine_namespaces(($namespace, $enum_type))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    

    

    <xsl:function name="cdit:declare_union_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="tab" as="xs:integer" />


        <xsl:variable name="descriminator_enum_type" select="cdit:get_union_descrimantor_type($aggregate)" />
        <xsl:variable name="descriminator_type" select="$descriminator_enum_type" />
        <xsl:variable name="descriminator_var" select="'descriminator_'" />
        <xsl:variable name="unset_enum" select="'UNSET'" />


        <!-- Public Declarations -->
        <xsl:value-of select="cpp:public($tab)" />
        <xsl:value-of select="cpp:comment('Union Descriminator', $tab + 1)" />

        <!-- Define the Enum -->
        <xsl:value-of select="cpp:enum($descriminator_enum_type, $tab + 1)" />
        
        <xsl:value-of select="cpp:enum_value($unset_enum, 0, false(), $tab + 2)" />
        <xsl:for-each select="graphml:get_child_nodes($aggregate)">
            <xsl:variable name="member_label" select="upper-case(graphml:get_label(.))" />
            <xsl:value-of select="cpp:enum_value($member_label, position(), position() = last(), $tab + 2)" />
        </xsl:for-each>
        <xsl:value-of select="cpp:scope_end($tab + 1)" />
        
        <xsl:value-of select="cpp:declare_function($descriminator_type, 'get_descriminator', '', ' const;', $tab + 1)" />

        <!-- Protected Declarations -->
        <xsl:value-of select="cpp:protected($tab)" />
        <xsl:value-of select="cpp:declare_function('void', 'set_descriminator', cpp:define_variable($descriminator_type, 'descriminator', '', '', 0), ';', $tab + 1)" />
        
        <!-- Private Declarations -->
        <xsl:value-of select="cpp:private($tab)" />
        <xsl:value-of select="cpp:define_variable($descriminator_type, $descriminator_var, cpp:combine_namespaces(($descriminator_type, $unset_enum)), cpp:nl(), $tab + 1)" />
    </xsl:function>

    <xsl:function name="cdit:define_union_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="class_name" as="xs:string" />
        

        <xsl:variable name="descriminator_enum_type" select="cpp:combine_namespaces(($class_name, cdit:get_union_descrimantor_type($aggregate)))" />
        <xsl:variable name="descriminator_type" select="$descriminator_enum_type" />
        <xsl:variable name="descriminator_var" select="'descriminator_'" />

        <!-- Getter -->
        <xsl:value-of select="cpp:define_function($descriminator_type, $class_name, 'get_descriminator', '', concat(' const', cpp:scope_start(0)))" />
        <xsl:value-of select="cpp:return($descriminator_var, 1)" />
        <xsl:value-of select="cpp:scope_end(0)" />
        <xsl:value-of select="o:nl(1)" />

        <!-- Setter -->
        <xsl:value-of select="cpp:define_function('void', $class_name, 'set_descriminator', o:join_list(($descriminator_type, 'descriminator'), ' '), cpp:scope_start(0))" />
        <xsl:value-of select="cpp:define_variable('', $descriminator_var, 'descriminator', cpp:nl(), 1)" />
        <xsl:value-of select="cpp:scope_end(0)" />
        <xsl:value-of select="o:nl(1)" />
    </xsl:function>

    <xsl:function name="cdit:define_datatype_functions">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="element" as="element()" />
        <xsl:param name="class_name" as="xs:string" />
        
        <xsl:variable name="label" select="graphml:get_label($element)" />
        <xsl:variable name="cpp_type" select="cpp:get_qualified_type($element)" />
        <xsl:variable name="var_label" select="cdit:get_variable_name($element)" />
        <xsl:variable name="kind" select="graphml:get_kind($element)" />

        <xsl:variable name="is_attribute" select="$kind = 'Attribute'" />

        <xsl:variable name="is_union" select="graphml:evaluate_data_value_as_boolean($aggregate, 'is_union')" />
        <xsl:variable name="descriminator_enum_type" select="cdit:get_union_descrimantor_type($aggregate)" />
        <xsl:variable name="enum_val" select="cpp:combine_namespaces(($descriminator_enum_type, upper-case($label)))" />
        <xsl:variable name="notset_enum_val" select="cpp:combine_namespaces(($descriminator_enum_type, 'UNSET'))" />
        <xsl:variable name="descriminator_var" select="'descriminator_'" />
        

        <xsl:if test="$cpp_type != ''">
                <!-- Define Setter Function -->
                <xsl:value-of select="cpp:define_function('void', $class_name, concat('set_', $label), cpp:const_ref_var_def($cpp_type, 'value'), cpp:scope_start(0))" />
                    <xsl:choose>
                        <xsl:when test="$is_attribute">
                            <xsl:value-of select="cpp:invoke_function($var_label, cpp:arrow(), cdit:get_attribute_set_function($element), 'value', 1)" />
                            <xsl:value-of select="cpp:nl()" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$is_union">
                                <xsl:value-of select="cpp:comment('Set the union descriminator on set', 1)" />
                                <xsl:value-of select="cpp:invoke_function('', '', 'set_descriminator', $enum_val, 1)" />
                                <xsl:value-of select="cpp:nl()" />
                            </xsl:if>
                            <xsl:value-of select="cpp:define_variable('', $var_label, 'value', cpp:nl(), 1)" />
                        </xsl:otherwise>
                    </xsl:choose>
                <xsl:value-of select="cpp:scope_end(0)" />
                <xsl:value-of select="o:nl(1)" />

                <!-- Define Getter Function -->
                <xsl:value-of select="cpp:define_function(cpp:const_ref_var_def($cpp_type, ''), $class_name, concat('get_', $label), '', concat(' const', cpp:scope_start(0)))" />
                    <xsl:choose>
                        <xsl:when test="$is_attribute">
                            <xsl:variable name="get_var" select="cpp:invoke_function($var_label, cpp:arrow(), cdit:get_attribute_ref_function($element), '', 0)" />
                            <xsl:value-of select="cpp:return($get_var, 1)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$is_union">
                                <xsl:value-of select="cpp:if_not(o:join_list(($descriminator_var, '==', $enum_val), ' '), cpp:scope_start(0), 1)" />
                                    <xsl:value-of select="cpp:cerr(o:wrap_dblquote(concat(o:wrap_quote(concat($class_name, '::get_', $label)), ': Descriminator is not set as: ', $enum_val)), 2)" />
                                <xsl:value-of select="cpp:scope_end(1)" />
                            </xsl:if>
                           
                            <xsl:value-of select="cpp:return($var_label, 1)" />
                        </xsl:otherwise>
                    </xsl:choose>
                <xsl:value-of select="cpp:scope_end(0)" />
                <xsl:value-of select="o:nl(1)" />

                <!-- Define Ref Getter Function -->
                <xsl:value-of select="cpp:define_function(cpp:ref_var_def($cpp_type, ''), $class_name, $label, '', cpp:scope_start(0))" />
                    <xsl:choose>
                        <xsl:when test="$is_attribute">
                            <xsl:variable name="get_var" select="cpp:invoke_function($var_label, cpp:arrow(), cdit:get_attribute_ref_function($element), '', 0)" />
                            <xsl:value-of select="cpp:return($get_var, 1)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$is_union">
                                <xsl:value-of select="cpp:if_not(o:join_list(($descriminator_var, '==', $enum_val, cpp:or(), $descriminator_var, '==', $notset_enum_val), ' '), cpp:scope_start(0), 1)" />
                                    <xsl:value-of select="cpp:cerr(o:wrap_dblquote(concat(o:wrap_quote(concat($class_name, '::', $label)), ': Descriminator is not set as: ', $enum_val)), 2)" />
                                <xsl:value-of select="cpp:scope_end(1)" />

                                <xsl:value-of select="cpp:comment('Set the union descriminator on set', 1)" />
                                <xsl:value-of select="cpp:invoke_function('', '', 'set_descriminator', $enum_val, 1)" />
                                <xsl:value-of select="cpp:nl()" />
                            </xsl:if>
                            <xsl:value-of select="cpp:return($var_label, 1)" />
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:value-of select="cpp:scope_end(0)" />
                <xsl:value-of select="o:nl(1)" />
            </xsl:if>
    </xsl:function>

    <xsl:function name="cdit:get_attribute_enum_type" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="cpp:combine_namespaces(('ATTRIBUTE_TYPE', upper-case(graphml:get_type($attribute))))" />
    </xsl:function>	

    <xsl:function name="cdit:get_attribute_set_function" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="o:join_list(('set', graphml:get_type($attribute)), '_')" />
    </xsl:function>	

    <xsl:function name="cdit:get_attribute_get_function" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="o:join_list(('get', graphml:get_type($attribute)), '_')" />
    </xsl:function>

    <xsl:function name="cdit:get_attribute_ref_function" as="xs:string">
        <xsl:param name="attribute" as="element()"  />
        <xsl:value-of select="graphml:get_type($attribute)" />
    </xsl:function>

    <xsl:function name="cdit:get_unique_class" as="element()*">
        <xsl:param name="component_impl" as="element()"  />

        <xsl:variable name="classes" select="graphml:get_child_nodes_of_kind($component_impl, 'ClassInstance')" />

        <xsl:for-each-group select="$classes" group-by="graphml:get_definition(.)">
            <xsl:if test="graphml:is_ignored_worker_type(.) = false()">
                <xsl:sequence select="." />
            </xsl:if>
        </xsl:for-each-group>
    </xsl:function>

    <xsl:function name="cdit:get_class_type" as="xs:string">
        <xsl:param name="class" as="element()"  />

        <xsl:choose>
            <xsl:when test="graphml:is_class_instance_worker($class)">
                <!-- Is Worker -->
                <xsl:value-of select="graphml:get_type($class)" />
            </xsl:when>
            <xsl:otherwise>
                <!-- Is Custom Class -->
                <xsl:value-of select="o:title_case(graphml:get_label($class))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:function name="cdit:get_qualified_class_type" as="xs:string">
        <xsl:param name="class" as="element()"  />

        <xsl:variable name="definition" select="graphml:get_definition($class)" />
        <xsl:variable name="namespace" select="graphml:get_namespace($definition)" />
        <xsl:variable name="type" select="cdit:get_class_type($class)" />

        <xsl:value-of select="cpp:combine_namespaces(($namespace, $type))" />
    </xsl:function>

    <xsl:function name="cdit:define_class_variable" as="xs:string*">
        <xsl:param name="class" as="element()"  />
        <xsl:param name="tab" as="xs:integer"  />

        <xsl:variable name="type" select="cdit:get_qualified_class_type($class)" />
        <xsl:variable name="label" select="graphml:get_data_value($class, 'label')" />
        <xsl:variable name="variable" select="cdit:get_variable_name($class)" />

        <xsl:variable name="getter" select="cpp:invoke_templated_static_function($type, 'AddTypedWorker', o:wrap_dblquote($label), '', 0)" />

        <xsl:value-of select="cdit:comment_graphml_node($class, $tab)" />
        <xsl:value-of select="cpp:define_variable('', $variable, $getter, cpp:nl(), $tab)" />
    </xsl:function>

    <xsl:function name="cdit:declare_class_variable" as="xs:string*">
        <xsl:param name="class" as="element()"  />
        <xsl:param name="tab" as="xs:integer"  />

        <xsl:variable name="type" select="cdit:get_qualified_class_type($class)" />
        <xsl:variable name="name" select="cdit:get_variable_name($class)" />

        <xsl:value-of select="cdit:comment_graphml_node($class, $tab)" />
        <xsl:value-of select="cpp:declare_variable(cpp:shared_ptr($type), $name, cpp:nl(), $tab)" />
    </xsl:function>



    <xsl:function name="cdit:get_worker_path" as="xs:string">
        <xsl:param name="worker" as="element()"  />
        <xsl:variable name="worker_folder" select="lower-case(graphml:get_data_value($worker, 'folder'))" />
        
        <xsl:variable name="rel_folder" select="replace($worker_folder, '\$\{re_path\}/src/', '')" />
        <xsl:value-of select="$rel_folder" />
    </xsl:function>



    


    <!-- NEWLY COMMMENTED -->

    <!--
        Get the Header file for a Class/Worker
    -->
    <xsl:function name="cdit:get_class_header" as="xs:string?">
        <xsl:param name="class" as="element(gml:node)"  />
        <xsl:variable name="class_def" select="graphml:get_definition($class)" />

        <xsl:choose>
            <xsl:when test="graphml:is_class_a_worker($class)">
                <xsl:variable name="worker_type" select="graphml:get_class_worker_type($class)" />

                <xsl:if test="graphml:is_ignored_worker_type($class) = false()">
                    <xsl:variable name="worker_file" select="lower-case(graphml:get_data_value($class_def, 'file'))" />
                    <xsl:value-of select="o:join_paths((cdit:get_worker_path($class_def), concat($worker_file, '.h')))" />
                </xsl:if>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="path" select="cdit:get_namespace_type_path($class_def)" />
                <xsl:variable name="header_file" select="lower-case(graphml:get_label($class_def))" />
                <xsl:value-of select="o:join_paths(('classes', $path, concat($header_file, '.h')))" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <!--
        Gets the Qualified CPP Enum Type for a middleware
    -->
    <xsl:function name="cdit:get_qualified_enum_type" as="xs:string">
        <xsl:param name="enum_instance" as="element(gml:node)"/>
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="enum_definition" select="graphml:get_definition($enum_instance)" />
        
        <xsl:variable name="enum_type" select="cdit:get_enum_type($enum_definition, $middleware)" />
        <xsl:variable name="enum_namespace" select="graphml:get_namespace($enum_definition)" />

        <xsl:variable name="namespace" as="xs:string*">
            <xsl:choose>
                <xsl:when test="$middleware = 'base'">
                    <xsl:sequence select="cpp:combine_namespaces(('Base', $enum_namespace))" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="$enum_namespace" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="suffix" as="xs:string*">
            <xsl:if test="$middleware = 'rti'">
                <!-- RTI uses Safe Enums which need to be exposed via an inner_enum -->
                <xsl:value-of select="'inner_enum'" />
            </xsl:if>
        </xsl:variable>

        <xsl:value-of select="concat('::', cpp:combine_namespaces(($namespace, $enum_type, $suffix)))" />
    </xsl:function>


    <!--
        Gets the Qualified CPP Enum Member Type
    -->
    <xsl:function name="cdit:get_qualified_enum_member_type" as="xs:string">
        <xsl:param name="enum_member" as="element(gml:node)"/>

        <xsl:variable name="enum" select="graphml:get_parent_node($enum_member)" />
        
        <xsl:variable name="enum_val" select="upper-case(graphml:get_label($enum_member))" />
        <xsl:variable name="enum_type" select="cdit:get_qualified_enum_type($enum, 'base')" />

        <xsl:value-of select="cpp:combine_namespaces(($enum_type, $enum_val))" />
    </xsl:function>

    <!--
        Gets the Qualified CPP Return Parameter for a Function
    -->
    <xsl:function name="cdit:get_function_return_type" as="xs:string*">
        <xsl:param name="function" as="element(gml:node)"/>

        <!-- Get the children of the ReturnParameterGroup-->
        <xsl:variable name="return_parameter_group" select="graphml:get_child_nodes_of_kind($function, ('ReturnParameterGroup', 'ReturnParameterGroupInstance'))" />
        <xsl:variable name="return_parameters" select="graphml:get_child_nodes($return_parameter_group)" />

        <xsl:choose>
            <xsl:when test="count($return_parameters) = 1" >
                <xsl:value-of select="cpp:get_qualified_type($return_parameters[1])" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'void'" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <!--
        Gets the Qualified CPP Function Parameters for a Function
    -->
    <xsl:function name="cdit:get_function_parameters" as="xs:string*">
        <xsl:param name="function" as="element(gml:node)"/>

        <xsl:variable name="input_parameter_group" select="graphml:get_child_nodes_of_kind($function, ('InputParameterGroup', 'InputParameterGroupInstance'))" />

        <xsl:variable name="resolved_args" as="xs:string*">
            <xsl:for-each select="graphml:get_child_nodes($input_parameter_group)">
                <xsl:variable name="kind" select="graphml:get_kind(.)" />
                <xsl:variable name="cpp_type" select="cpp:get_qualified_type(.)" />
                <xsl:variable name="var_label" select="cdit:get_variable_name(.)" />

                <xsl:choose>
                    <xsl:when test="($kind = 'Member' or
                                    $kind = 'MemberInstance') and
                                    cpp:is_primitive_type($cpp_type)">
                        <xsl:value-of select="cpp:var_def($cpp_type, $var_label)" />
                    </xsl:when>
                    <xsl:when test="$kind = 'EnumInstance'">
                        <xsl:value-of select="cpp:var_def($cpp_type, $var_label)" />
                    </xsl:when>
                    <xsl:when test="$cpp_type and
                                    $cpp_type != 'void'" >
                        <xsl:value-of select="cpp:ref_var_def($cpp_type, $var_label)" />
                    </xsl:when>
                </xsl:choose>
            </xsl:for-each>
        </xsl:variable>
        <xsl:sequence select="cpp:join_args($resolved_args)" />
    </xsl:function>

    

    <!--
        Gets the Template Type for a ServerInterface
    -->
    <xsl:function name="cdit:get_server_interface_template_type" as="xs:string">
        <xsl:param name="server_interface" as="element(gml:node)?" />

        <xsl:variable name="reply_type" select="cdit:get_qualified_reply_type_for_server_interface($server_interface, 'base')" />
        <xsl:variable name="request_type" select="cdit:get_qualified_request_type_for_server_interface($server_interface, 'base')" />

        <xsl:value-of select="cpp:join_args(($reply_type, $request_type))" />
    </xsl:function>

    <!--
        Gets the Qualified CPP Function Parameters for a RequesterPort
    -->
    <xsl:function name="cdit:get_requester_port_function_parameters" as="xs:string">
        <xsl:param name="server_interface" as="element(gml:node)?" />

        <xsl:variable name="base_request_type" select="cdit:get_qualified_request_type_for_server_interface($server_interface, 'base')" />
        
        <xsl:variable name="args" as="xs:string*">
            <xsl:if test="$base_request_type != 'void'">
                <xsl:sequence select="cpp:ref_var_def($base_request_type, 'm')" />
            </xsl:if>
            <xsl:sequence select="cpp:const_ref_var_def('std::chrono::milliseconds', 'timeout')" />
        </xsl:variable>
        <xsl:value-of select="cpp:join_args($args)" />
    </xsl:function>

    <!--
        Gets the Qualified CPP Return Parameter for a RequesterPort
    -->
    <xsl:function name="cdit:get_requester_port_return_type">
        <xsl:param name="server_interface" as="element()" />

        <xsl:variable name="base_request_type" select="cdit:get_qualified_reply_type_for_server_interface($server_interface, 'base')" />
        <xsl:choose>
            <xsl:when test="$base_request_type = 'void'">
                <xsl:value-of select="'bool'" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="cpp:define_pair('bool', $base_request_type)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <!--
        Gets the Qualified CPP Function Parameters for a ReplierPort
    -->
    <xsl:function name="cdit:get_replier_port_function_parameters" as="xs:string?">
        <xsl:param name="server_interface" as="element(gml:node)?" />

        <xsl:variable name="base_request_type" select="cdit:get_qualified_request_type_for_server_interface($server_interface, 'base')" />

        <xsl:if test="$base_request_type != 'void'">
            <xsl:value-of select="cpp:ref_var_def($base_request_type, 'm')" />
        </xsl:if>
    </xsl:function>

    <!--
        Gets the Qualified CPP request type for a ServerInterface for a particular middleware
    -->
    <xsl:function name="cdit:get_qualified_request_type_for_server_interface" as="xs:string">
        <xsl:param name="server_interface" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="server_requests" select="cdit:get_server_interface_request_aggregates($server_interface)" />
        
        <xsl:choose>
            <xsl:when test="count($server_requests) = 1">
                <xsl:value-of select="cdit:get_aggregate_qualified_type($server_requests[1], $middleware)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'void'" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <!--
        Gets the Qualified CPP reply type for a ServerInterface for a particular middleware
    -->
    <xsl:function name="cdit:get_qualified_reply_type_for_server_interface" as="xs:string?">
        <xsl:param name="server_interface" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="server_replies" select="cdit:get_server_interface_reply_aggregates($server_interface)" />
        
        <xsl:choose>
            <xsl:when test="count($server_replies) = 1">
                <xsl:value-of select="cdit:get_aggregate_qualified_type($server_replies[1], $middleware)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'void'" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <!--
        Gets the Request Aggregate for a Server Interface
    -->
     <xsl:function name="cdit:get_server_interface_request_aggregates" as="element(gml:node)?">
        <xsl:param name="server_interface" as="element(gml:node)?" />

        <xsl:variable name="request_type" select="graphml:get_child_nodes_of_kind($server_interface, 'InputParameterGroup')" />
        <xsl:sequence select="graphml:get_child_nodes_of_kind($request_type, 'AggregateInstance')" />
    </xsl:function>

    <!--
        Gets the Reply Aggregate for a Server Interface
    -->
    <xsl:function name="cdit:get_server_interface_reply_aggregates" as="element(gml:node)?">
        <xsl:param name="server_interface" as="element(gml:node)?" />

        <xsl:variable name="request_type" select="graphml:get_child_nodes_of_kind($server_interface, 'ReturnParameterGroup')" />
        <xsl:sequence select="graphml:get_child_nodes_of_kind($request_type, 'AggregateInstance')" />
    </xsl:function>

    <!--
        Creates a unique variable name for an entity
    -->
    <xsl:function name="cdit:get_unique_variable_name" as="xs:string?">
        <xsl:param name="entity" as="element(gml:node)?"/>
        <xsl:variable name="name" select="cdit:get_variable_name($entity)" />
        <xsl:variable name="id" select="graphml:get_id($entity)" />

        <xsl:value-of select="lower-case(o:join_list(($name, $id), '_'))"/>
    </xsl:function>

    <!--
        Gets a variable name for an entity
    -->
    <xsl:function name="cdit:get_variable_name" as="xs:string?">
        <xsl:param name="entity" as="element(gml:node)?"/>
        
        <xsl:variable name="kind" select="graphml:get_kind($entity)" />
        
        <xsl:choose>
            <xsl:when test="$kind = 'FunctionCall'">
                <xsl:variable name="function_def" select="graphml:get_first_definition($entity)" />
                <xsl:variable name="function_def_parent" select="graphml:get_parent_node($function_def)" />
                
                <!-- If the function call is referring to a Function defined in our Component, its locally scoped, so no name  -->
                <xsl:if test="not(graphml:is_descendant_of($entity, $function_def_parent))">
                    <xsl:value-of select="cdit:get_variable_name($function_def_parent)"/>
                </xsl:if>
            </xsl:when>
            <!-- Void type never has a name -->
            <xsl:when test="$kind = 'VoidType'" />
            <xsl:when test="$kind = 'Setter'">
                <xsl:variable name="kind" select="lower-case(graphml:get_kind($entity))" />
                <xsl:value-of select="cdit:get_variable_label($kind, $entity)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="label" select="lower-case(graphml:get_label($entity))" />
                <xsl:value-of select="cdit:get_variable_label($label, $entity)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <!--
        Gets a list of utilized middlewares
    -->
    <xsl:function name="cdit:get_utilized_middlewares" as="xs:string*">
        <xsl:param name="model" as="element(gml:node)" />
        <xsl:param name="generate_all" as="xs:boolean" />
        
        <xsl:variable name="deployed_ports" select="graphml:get_deployed_port_instances($model)" />
        <xsl:variable name="middlewares" select="graphml:get_data_values($deployed_ports, 'middleware')" />

        <xsl:variable name="required_middlewares">
            <xsl:choose>
                <xsl:when test="$generate_all = false()">
                    <xsl:sequence select="$middlewares" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="cdit:get_all_middlewares()" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:sequence select="cdit:sanitize_middleware_list($required_middlewares)" />
    </xsl:function>

    <!--
        Sanitizes a middleware list and adds required sub-middlewares
    -->
    <xsl:function name="cdit:sanitize_middleware_list" as="xs:string*">
        <xsl:param name="middlewares" as="xs:string*"/>
        
        <!-- Flatten and lower-case the middlewares -->
        <xsl:variable name="flattened_middlewares" select="normalize-space(lower-case($middlewares))" />

        <xsl:variable name="required_middlewares" as="xs:string*">
            <!-- Always need the base middleware -->
            <xsl:sequence select="'base'" />
            
            <xsl:for-each select="tokenize($flattened_middlewares, ' ')">
                <xsl:variable name="middleware" select="." />
                <xsl:sequence select="$middleware" />
                <!-- Include the middlewares which required protobuf -->
                <xsl:if test="cdit:middleware_uses_protobuf($middleware)">
                    <xsl:sequence select="'proto'" />
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>

        <!-- Return the unique middleware -->
        <xsl:sequence select="distinct-values($required_middlewares)"/>
    </xsl:function>

    <xsl:function name="cdit:get_components_to_build" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="generate_all" as="xs:boolean" />

        <xsl:variable name="required_components" as="element(gml:node)*">
            <xsl:choose>
                <xsl:when test="$generate_all = true()">
                    <xsl:sequence select="graphml:get_nodes_of_kind($model, 'ComponentImpl')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each select="graphml:get_deployed_component_instances($model)">
                        <xsl:sequence select="graphml:get_impl(.)" />
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:sequence select="o:remove_duplicates($required_components)" />
    </xsl:function>

    <xsl:function name="cdit:get_classes_to_build" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="generate_all" as="xs:boolean" />

        <xsl:variable name="required_classes" as="element(gml:node)*">
            <xsl:for-each select="cdit:get_components_to_build($model, $generate_all)">
                <xsl:for-each select="graphml:get_descendant_nodes_of_kind(., 'ClassInstance')">
                    <xsl:if test="graphml:is_class_instance_worker(.) = false()">
                        <xsl:sequence select="graphml:get_definition(.)" />
                    </xsl:if>
                </xsl:for-each>
            </xsl:for-each>
        </xsl:variable>

        <xsl:sequence select="o:remove_duplicates($required_classes)" />
    </xsl:function>

    <!--
        Gets the required Aggregates to generate for a particular middleware
    -->
    <xsl:function name="cdit:get_aggregates_for_middleware" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="generate_all" as="xs:boolean" />

        <xsl:variable name="required_aggregates" as="element(gml:node)*">
            <xsl:choose>
                <xsl:when test="$generate_all">
                    <!-- Get All Aggregates -->
                    <xsl:sequence select="graphml:get_nodes_of_kind($model, 'Aggregate')"/>
                </xsl:when>
                <xsl:otherwise>
                    <!-- Get all the Aggregates used by each deployed port instances -->
                    <xsl:for-each select="graphml:get_deployed_port_instances($model)[cdit:does_port_use_middleware(., $middleware)]">
                        <xsl:sequence select="cdit:get_required_aggregates(graphml:get_definition(.), false())"/>
                    </xsl:for-each>

                    <!-- Get all the Aggregates used by each deployed ComponentImpl -->
                    <xsl:if test="$middleware = 'base'">
                        <xsl:for-each select="graphml:get_deployed_component_instances($model)">
                            <xsl:sequence select="cdit:get_required_aggregates(graphml:get_impl(.), false())"/>
                        </xsl:for-each>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <!-- Filter out any non-aggregates -->
        <xsl:sequence select="graphml:get_definitions($required_aggregates)[graphml:get_kind(.) = 'Aggregate']" />
    </xsl:function>

    <!--
        Gets the required Aggregates to generate for a particular middleware
    -->
    <xsl:function name="cdit:get_enums_for_middleware" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="generate_all" as="xs:boolean" />

        <xsl:variable name="required_aggregates" select="cdit:get_aggregates_for_middleware($model, $middleware, $generate_all)" />

        <xsl:variable name="required_enum_instances" select="graphml:get_descendant_nodes_of_kind($required_aggregates, 'EnumInstance')" />

        <xsl:sequence select="graphml:get_definitions($required_enum_instances)" />
    </xsl:function>

    

    <!--
        Gets the required Pub/Sub Ports Aggregates (Definition) to generate for a particular middleware
    -->
    <xsl:function name="cdit:get_pubsub_aggregates_for_middleware" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="generate_all" as="xs:boolean" />
        
        <!-- Only Run if this middleware implements pub/sub -->
        <xsl:if test="cdit:middleware_implements_pubsub($middleware)">
            <xsl:variable name="port_definitions" as="element(gml:node)*">
                <xsl:choose>
                    <xsl:when test="$generate_all">
                        <!-- Get All Pub/Sub Port Definitions -->
                        <xsl:sequence select="graphml:get_nodes_of_kind($model, graphml:get_pubsub_port_kinds())"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- Only get the Deployed Pub/Sub Definitions -->
                        <xsl:for-each select="graphml:get_deployed_port_instances($model)
                            [
                                cdit:does_port_use_middleware(., $middleware) and
                                graphml:get_kind(.) = graphml:get_pubsub_port_instance_kinds()
                            ]">
                            <xsl:sequence select="graphml:get_definition(.)"/>
                        </xsl:for-each>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>

            <!-- Get the ports aggregate from each port-->
            <xsl:sequence select="o:remove_duplicates(for $x in $port_definitions return graphml:get_port_aggregate($x))"/>
        </xsl:if>
    </xsl:function>

    <!--
        Gets the required ServerInterface (Definition) to generate for a particular middleware
    -->
    <xsl:function name="cdit:get_serverinterfaces_for_middleware" as="element(gml:node)*">
        <xsl:param name="model" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />
        <xsl:param name="generate_all" as="xs:boolean" />
        
        <!-- Only Run if this middleware implements pub/sub -->
        <xsl:if test="cdit:middleware_implements_reqrep($middleware)">
            <xsl:variable name="port_definitions" as="element(gml:node)*">
                <xsl:choose>
                    <xsl:when test="$generate_all">
                        <!-- Get All ServerInterface Port Definitions -->
                        <xsl:sequence select="graphml:get_nodes_of_kind($model, graphml:get_reqrep_port_kinds())"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- Only get the Deployed Pub/Sub Definitions -->
                        <xsl:for-each select="graphml:get_deployed_port_instances($model)
                            [
                                cdit:does_port_use_middleware(., $middleware) and
                                graphml:get_kind(.) = graphml:get_reqrep_port_instance_kinds()
                            ]">
                            <xsl:sequence select="graphml:get_definition(.)"/>
                        </xsl:for-each>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>

            <!-- Get the ports aggregate from each port-->
            <xsl:sequence select="o:remove_duplicates(for $x in $port_definitions return graphml:get_port_aggregate($x))"/>
        </xsl:if>
    </xsl:function>

    <!--
        Gets the fully qualified type of an Aggregate
    -->
    <xsl:function name="cdit:get_aggregate_qualified_type" as="xs:string?">
        <xsl:param name="entity" as="element(gml:node)?" />
        <xsl:param name="middleware" as="xs:string" />

        <!-- Combine the namespace and type -->
        <xsl:variable name="aggregate_type" select="cdit:get_qualified_type($entity)" />
        
        <xsl:choose>
            <xsl:when test="$middleware = 'base'">
                <xsl:value-of select="cpp:combine_namespaces(('Base', $aggregate_type))" />
            </xsl:when>
            <xsl:when test="$aggregate_type">
                <!-- Append on Global Namespace -->
                <xsl:value-of select="concat('::', $aggregate_type)" />
            </xsl:when>
        </xsl:choose>
    </xsl:function>

    <!--
        Gets the fully qualified type of an Entity
    -->
    <xsl:function name="cdit:get_qualified_type" as="xs:string?">
        <xsl:param name="entity" as="element(gml:node)?" />
        
        <!-- Get the Type and Namespace of the Aggregate -->
        <xsl:variable name="entity_def" select="graphml:get_definition($entity)" />
        <xsl:variable name="namespace" select="graphml:get_namespace($entity_def)" />
        <xsl:variable name="type" select="cpp:get_aggregate_type_name($entity_def)" />

        <!-- Combine the namespace and type -->
        <xsl:value-of select="cpp:combine_namespaces(($namespace, $type))" />
    </xsl:function>

    

    <!--
        Gets the prefix to generate files for Aggregates with
    -->
    <xsl:function name="cdit:get_aggregate_file_prefix" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <!-- Get the Type and Namespace of the Aggregate -->
        <xsl:variable name="aggregate_def" select="graphml:get_definition($aggregate)" />

        <xsl:variable name="namespace" as="xs:string*">
            <xsl:if test="lower-case($middleware) != 'base'">
                <xsl:sequence select="graphml:get_namespace($aggregate_def)" />
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="type" select="cpp:get_aggregate_type_name($aggregate_def)" />

        <xsl:value-of select="lower-case(o:join_list(($namespace, $type), '_'))" />
    </xsl:function>

    <!--
        Gets the fully qualified path to a middlewares Aggregate
    -->
    <xsl:function name="cdit:get_aggregate_path_for_middleware" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="path" select="cdit:get_namespace_type_path($aggregate)" />
        <xsl:value-of select="lower-case(o:join_paths(('datatypes', $middleware, $path)))" />
    </xsl:function>
    
    <!--
        Gets the path of /namespace/type
    -->
    <xsl:function name="cdit:get_namespace_type_path" as="xs:string">
        <xsl:param name="aggregate" as="element()" />

        <xsl:variable name="aggregate_def" select="graphml:get_definition($aggregate)" />
        <xsl:variable name="namespace" select="graphml:get_namespace($aggregate_def)" />
        <xsl:variable name="type" select="cpp:get_aggregate_type_name($aggregate_def)" />

        <xsl:value-of select="lower-case(o:join_paths(($namespace, $type)))" />
    </xsl:function>

    <!-- Checks if a Port Instance uses a particular middleware -->
    <xsl:function name="cdit:does_port_use_middleware" as="xs:boolean">
        <xsl:param name="port_instance" as="element(gml:node)" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="port_middleware" select="graphml:get_middleware($port_instance)" />

        <xsl:value-of select="$middleware = $port_middleware or ($middleware='proto' and cdit:middleware_uses_protobuf($port_middleware)) or $middleware = 'base'" />
    </xsl:function>

    <!--
        Includes the Base Enum Headers
    -->
    <xsl:function name="cdit:include_enum_headers" as="xs:string?">
        <xsl:param name="enums" as="element(gml:node)*" />
        <xsl:value-of select="cdit:include_aggregate_headers($enums, 'base')" />
    </xsl:function>

    <!-- Includes the Aggregate Files Headers -->
    <xsl:function name="cdit:include_aggregate_headers">
        <xsl:param name="aggregates" as="element(gml:node)*" />
        <xsl:param name="middleware" as="xs:string" />

        <!-- For each Aggregate Definition -->
        <xsl:for-each select="graphml:get_definitions($aggregates)">
            <xsl:if test="position() = 1">
                <xsl:sequence select="cpp:comment(('Include required', o:wrap_quote($middleware), graphml:get_kind(.), 'header files'), 0)" />
            </xsl:if>
            
            <xsl:variable name="header_file" select="cdit:get_aggregates_generated_middleware_header_path(., $middleware)" />
            <xsl:sequence select="cpp:include_local_header($header_file)" />

            <xsl:if test="position() = last()">
                <xsl:sequence select="o:nl(1)" />
            </xsl:if>
        </xsl:for-each>
    </xsl:function>

    <xsl:function name="cdit:get_aggregates_generated_middleware_header_path" as="xs:string">
        <xsl:param name="aggregate" as="element()" />
        <xsl:param name="middleware" as="xs:string" />

        <xsl:variable name="file_path" select="cdit:get_aggregate_path_for_middleware($aggregate, $middleware)" />
        <xsl:variable name="file_name" select="cdit:get_middleware_generated_header_name($aggregate, $middleware)" />
        
        <xsl:value-of select="o:join_paths(($file_path, $file_name))" />
    </xsl:function>

    <!--
        Checks if a middleware implements req/rep ports
    -->
    <xsl:function name="cdit:middleware_implements_reqrep" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:variable name="supported_middlewares" select="('zmq', 'qpid', 'tao')" as="xs:string*" />
        <xsl:value-of select="$middleware = $supported_middlewares" />
    </xsl:function>

    <!--
        Checks if a middleware implements pub/sub ports
    -->
    <xsl:function name="cdit:middleware_implements_pubsub" as="xs:boolean">
        <xsl:param name="middleware" as="xs:string"/>
        <xsl:variable name="supported_middlewares" select="('zmq', 'qpid', 'rti', 'ospl')" as="xs:string*" />
        <xsl:value-of select="$middleware = $supported_middlewares" />
    </xsl:function>
</xsl:stylesheet>

